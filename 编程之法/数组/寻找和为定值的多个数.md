# 寻找和为定值的多个数
> Author ID.9276 

**问题关键词：**

- 

## 01 题目

输入两个整数n和sum，从数列1，2，3.......n 中随意取几个数，使其和等于sum，要求将其中所有的可能组合列出来

## 02 输入分析



## 03 解题思路

### 3.1 基础解法

- 分析：**其实是一个组合问题**
  - 治理要注意减治算法思维的使用：注意到取n，和不取n个区别即可，考虑是否取第n个数的策略，可以转化为一个只和前n-1个数相关的问题。 
    - 如果取第n个数，那么问题就转化为“取前n-1个数使得它们的和为sum-n”，对应的代码语句就是sumOfkNumber(sum - n, n - 1)
    - 如果不取第n个数，那么问题就转化为“取前n-1个数使得他们的和为sum”，对应的代码语句为sumOfkNumber(sum, n - 1)
  - 因此，使用递归算法即可

```c++
vector<int> ans;

void sumOfKNumber(int sum, int n) {
    if(n == 0 || sum <= 0) return;

    if(sum == n) {
        // cout the result
        print(ans);
    }

    ans.push_back(n);
    sumOfKNumber(sum-n, n-1); // have n
    ans.pop_back();
    sumOfKNumber(sum, n-1); // have no n
}
```

- 复杂度：
  - 时间：深度为 n 的二叉树，共有 2^n 个分枝
  - 空间：递归栈

### 3.2 优化

#### 子集和问题（背包问题）

- 分析

  - 采用回溯 + 剪枝的方法

- 算法

  - X数组是解向量，t=∑(1,..,k-1)Wi*Xi, r=∑(k,..,n)Wi，且

    - 若t+Wk+W(k+1)<=M,则Xk=true，递归左儿子(X1,X2,..,X(k-1),1)；否则剪枝；
    - 若t+r-Wk>=M && t+W(k+1)<=M,则置Xk=0，递归右儿子(X1,X2,..,X(k-1),0)；否则剪枝；

    本题中W数组就是(1,2,..,n),所以直接用k代替WK值。

```c++
//输入t， r， 尝试Wk
void SumOfkNumber(int t, int k, int r, int& M, bool& flag, bool* X)
{
    X[k] = true;   // 选第k个数
    if (t + k == M) // 若找到一个和为M，则设置解向量的标志位，输出解
    {
        flag = true;
        for (int i = 1; i <= k; ++i)
        {
            if (X[i] == 1)
            {
                printf("%d ", i);
            }
        }
        printf("\n");
    }
    else
    {   // 若第k+1个数满足条件，则递归左子树
        if (t + k + (k + 1) <= M)
        {
            SumOfkNumber(t + k, k + 1, r - k, M, flag, X);
        }
        // 若不选第k个数，选第k+1个数满足条件，则递归右子树
        if ((t + r - k >= M) && (t + (k + 1) <= M))
        {
            X[k] = false;
            SumOfkNumber(t, k + 1, r - k, M, flag, X);
        }
    }
}

void search(int& N, int& M)
{
    // 初始化解空间
    bool* X = (bool*)malloc(sizeof(bool)* (N + 1));
    memset(X, false, sizeof(bool)* (N + 1));
    int sum = (N + 1) * N * 0.5f;
    if (1 > M || sum < M) // 预先排除无解情况
    {
        printf("not found\n");
        return;
    }
    bool f = false;
    SumOfkNumber(0, 1, sum, M, f, X);
    if (!f)
    {
        printf("not found\n");
    }
    free(X);
}
```

## 04 问题总结

#### 背包问题

0-1背包问题是最基础的背包问题，其具体描述为：有N件物品和一个容量为V的背包。放入第i件物品耗费的费用是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。

简单分析下：这是最基础的背包问题，特点是每种物品仅有一件，可以选择放或不放。用子问题定义状态：即**F[i, v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值**。则其状态转移方程便是：

- F[i, v] = max{F[i-1, v], F[i-1, v-Ci ] + Wi}

根据前面的分析，我们不难理解这个方程的意义：“将前i件物品放入容量为v的背包中”这个子问题，**若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只和前 i-1 件物品相关的问题**。即：

- **如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为 F[i-1, v ]**；
- **如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-Ci的背包中”，此时能获得的最大价值就是F[i-1, v-Ci]再加上通过放入第i件物品获得的价值Wi**。

伪代码如下：

```c
F[0,0...V] ← 0
for i ← 1 to N
    for v ← Ci to V
        F[i, v] ← max{F[i-1, v], F[i-1, v-Ci] + Wi }
```

这段代码的**时间和空间复杂度均为 O(VN)**，其中**时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到O(V)**。感兴趣的读者可以继续思考或者参考网上一个不错的文档《背包问题九讲》。

### 问题拓展

#### 抽签问题

将写有数字的n个纸片放入一个纸箱子中，然后你和你的朋友从纸箱子中抽取4张纸片，每次记下纸片上的数字后放回子箱子中，如果这4个数字的和是m，代表你赢，否则就是你的朋友赢

请编写一个程序，当纸片上所写的数字是k1，k2，k3，k4，..，kn时，是否存在抽取4次和为m的方案，如果存在，输出YES；否则，输出NO

- 限制条件：
  - 1 <= n <= 50
  - 1 <= m <= 10^8
  - 1 <= ki <= 10^8



- 穷举搜索：
  - 最容易想到的方案是用4个for循环直接穷举所有方案，时间复杂度为O（N^4）
  - 当n远大于50时，则程序会显得非常吃力

```c++
//通过4重for循环枚举所有方案
for (int a = 0; a < n, a++)
{
    for (int b = 0; b < n; b++)
    {
        for (int c = 0; c < n; c++)
        {
            for (int d = 0; d < n; d++)
            {
                if (k[a] + k[b] + k[c] + k[d] == m)
                {
                    f = true;
                }
            }
        }
    }
}
```

- 优化策略：查找问题
  - 内部的循环其实实在**查找**目标值是否在序列中，因此我们可以将这个循环换成 hash 表
  - 将c + d 提前计算好建立 hash 表，然后查找即即可
    - 或者对序列排序，二分查找可行
  - 复杂度下降到 O(n^2)

#### 是否存在和为 k 的组合

给定整数a1、a2、a3、...、an，判断是否可以从中选出若干个数，使得它们的和等于k（k任意给定，且满足-10^8 <= k <= 10^8）

- 分析
  - 此题相对于本节“寻找满足条件的多个数”如出一辙，不同的是此题只要求判断，不要求把所有可能的组合给输出来。因为此题需要考虑到加上a[i]和不加上a[i]的情况，故可以采用深度优先搜索的办法，递归解决。
  - DFS 即可

#### 和为 S 的 K 个数

有n个数，输出期中所有和为s的k个数的组合

- 分析：
  - 此题有两个坑，一是这里的n个数是任意给定的，不一定是：1,2,3...n，所以可能有重复的数（如果有重复的数怎么处理？）；二是不要求你输出所有和为s的全部组合，而只要求输出和为s的k个数的组合

举个例子，假定n=6，这6个数为：1 2 1 3 0 1，如果要求输出和为3的全部组合的话，

- 1 2
- 1 2 0
- 0 3
- 1 1 1
- 1 1 1 0

而题目加了个限制条件，若令k=2，则只要求输出：[{1,2}, {0,3}] 即可。