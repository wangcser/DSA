# 算法设计中的数学方法与常见模型

## 代数方法

- 字母代替数字对问题进行一般化
- 分类讨论
- 复数工具用于旋转和伸缩
- 向量工具用于变换和伸缩
- 用矩阵描述复杂对象和变换
- 方程组模型帮助理解约束

## 初等数论

### prime

- 整除：整除关系是一个偏序关系
- 约束：整除中的因子
- 素数：大于 1 的正整数 p，如果 p 仅有正因子 1 和 p，则 p 称为素数（prime）
- 合数：大于 1 的又不是素数的正整数
  - 如果 n 为合数，则 n 必有一个小于等于 $\sqrt{n}$ 的素因子
- 算术基本定理：任何正整数都可唯一地表示为素数的乘积
- 除法：a 为整数，d 为正整数，那么有唯一的整数 q 和 r，其中 0 <= r < d，满足 a = dq + r
  - d 为除数
  - a 为被除数
  - q 为商
  - r 为余数
- 同余：两个数除以同样的一个数，其余数相等

### gcd 和 lcm

- 最大公约数(greatest common divisor, gcd)：gcd(a, b)
  - 穷举法：列出所有公共因子
  - 质因数分解法：列出公共素因子，计算其共同项的乘积
  - 短除法：两数除以其共同[质因数](https://zh.wikipedia.org/wiki/質因數)，直到两数[互质](https://zh.wikipedia.org/wiki/互質)时，所有除数的乘积即为最大公因数
  - **辗转相除法**：两数相除，取馀数重复进行相除，直到馀数为 0 时，前一个除数即为最大公因数
- 最小公倍数(least common multiple, lcm)：lcm(a, b)
  - 枚举法：枚举二者的公共倍数
  - 质因数分解法：求二者分解的并集合，然后取其乘积
  - 利用 gcd 求 lcm：见下面的公式
- gcd 与 lcm 的关系： $gcd(a, b) \times lcm(a, b) = \|a \times b\|$ 
  - 因此二者可以相互计算
- 互素（互质）：两数的 gcd 为 1

**gcd 的实现：迭代法（辗转相除法）**

- 核心：gcd(a, b) = gcd(b, a mod b) **(a > b)**

### 素数的判定

用于解决下面两个问题：

- 判断一个数是否为素数
  - 朴素判别法：从 2 开始试除所有小于 n 的自然数，复杂度 O(n)
  - **平方优化：只需要尝试到 $\sqrt{n}$ 即可，复杂度 $O(n^{1/2})$**
  - 查表法：先建表备查
- 求 1 ~ n 之间所有的素数
  - 素数筛法：每找到一个素数，就从集合中去掉它和它的倍数

更快的算法——Miller-Rabbin 算法（属于 Motne-Carlo 算法）

### 位进制

- 快速幂取模
- 康托展开

### 同余模运算

- 欧拉定理
- 费马定理
- 中国剩余定理

## 组合数学

对集合中的对象进行满足规则的排列，研究这种排列的：

- 存在性
- 计数
- 分类

### 鸽笼原理

n + 1 物体放入 n 个盒子，则至少有一个盒子包含两个或更多的物体

### 加法原理

将事情分为 N 类，每类有 Ci 种做法，则该事情共有 sum(Ci) 种做法

### 乘法原理

将事情分为 N 步，每步 Ci 种做法，则该事情共有 sigma(Ci) 种做法

### Stirling 公式

为了计算 N 的阶乘，当 N 很大时，可以使用下面的近似公式：
$$
n! = \sqrt{2 \pi n}(\frac{\pi}{e})^n
$$

### 容斥原理

### 群论

- 置换群

### 递推关系与生成函数

- Fibonacci

### 离散变换与反演

### 图论

- 生成树
  - prim
  - kruskal
- 最短路
  - dijkstra
  - bellman-ford
  - floyd-warshall
- 网络流
  - max flow
  - min cut
- 二分图
  - 任务安排问题 —— 点覆盖问题

## 计算几何（略）