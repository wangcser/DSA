# 随机算法

问题假设：

- 下文使用的随机函数都假设它能够产生范围 [a. b] 内的整数，也就是产生每个整数的概率相等

## 随机排列数组

### 问题

给定数组 A，包含元素 1 到 N，我们的目标是构造这个数组的一个随机序列

### 方法一：赋予随机权重，按权重排序

- 分析：
  - 直接对区间内元素取随机数容易碰撞，因此我们可以使用一个较大的随机区间
- 方案：
  - 为数组中的每一个元素选择一个随机的优先级，这个优先级在一个很大的范围内取到（想象比特币钱包随机数的产生，256 位不产生碰撞）
  - 按照优先级对数组进行排序

### 方法二：原地随机排列

- 分析：

  - 类比选择排序和插入排序，将序列分为两个部分

- 方案

  - 将序列分为两个部分，左边为结果序列，右边为可用元素
  - 从右边序列中随机选择一个元素和头部元素交换，然后向右移动待选择序列

  > 第i次迭代时，元素A[i]是从元素A[i]到A[n]中随机选取的，在第i次迭代后，我们就再也不会改变A[i]

```
RANDOMIZE-IN-PLACE ( A , n )
     for i ←1 to n
          do swap A[i] ↔A[RANDOM(i , n )]
```

- 证明：A[i]位于任意位置j的概率为1/n

> 算法RANDOMIZE-IN-PLACE可以产生均匀随机排列，它的证明过程如下：
>
> 首先给出k排列的概念，所谓k排列就是从n个元素中选取k个元素的排列，那么它一共有n!/(n-k)!个k排列。
>
> 循环不变式：for循环第i次迭代前，对于每个可能的i-1排列，子数组A[1...i-1]包含该i-1排列的概率为(n-i+1)! / n!。
>
> 初始化：在第一次迭代前，i=1，则循环不变式指的是对于每个0排列，子数组A[1...i-1]包含该0排列的概率为(n-1+1)! / n! = 1。A[1...0]为空的数组，0排列则没有任何元素，因此A包含所有可能的0排列的概率为1。不变式成立。
>
> 维持：假设在第i次迭代前，数组的i-1排列出现在A[1...i-1]的概率为(n-i+1) !/ n!，那么在第i次迭代后，数组的所有i排列出现在A[1...i]的概率为(n-i)! / n!。下面来推导这个结论：
>
> 考虑一个特殊的i排列p = {x1, x2, ... xi}，它由一个i-1排列p' ={x1, x2,..., xi−1}后面跟一个xi构成。设定两个事件变量E1和E2：
>
> E1为该算法将排列p‘放置到A[1...i-1]的事件，概率由归纳假设得知为Pr(E1) = (n-i+1)! / n!。
>
> E2为在第i次迭代时将xi放入到A[i]的事件。
>
> 因此我们得到i排列出现在A[1...i]的概率为Pr {E2 ∩ E1} = Pr {E2 | E1} Pr {E1}.而Pr {E2 | E1} = 1/(n − i + 1)，所以
>
> Pr {E2 ∩ E1} = Pr {E2 | E1} Pr {E1}= 1 /(n − i + 1) * (n − i + 1)! / n! = (n − i )! / n!。
>
> 结束：结束的时候i=n+1，因此可以得到A[1...n]是一个给定n排列的概率为1/n！。

## 随机选择一个数字

### 问题

给定一个未知长度的整数流，如何随机选取一个数？（所谓随机就是保证每个数被选取的概率相等）

### 方法一：先缓存，再当做固定长度的情况枚举概率即可

如果数据流不是很长，可以存在数组中，然后再从数组中随机选取。当然题目说的是未知长度，所以如果长度很大不足以保存在内存中的话会很麻烦。这种解法有其局限性。

### 方法二：替换法

- 分析：
  - 每加入一个元素，我们就尝试用这个元素替换之前选中的元素
- 方案：
  - 如果数据流在第1个数字后结束，那么必选第1个数字
  - 如果数据流在第2个数字后结束，那么我们选第2个数字的概率为1/2，我们以1/2的概率用第2个数字替换前面选的随机数，得到新的随机数
  - …
  - 如果数据流在第n个数字后结束，那么我们选择第n个数字的概率为1/n，即我们以1/n的概率用第n个数字替换前面选的随机数，得到新的随机数

```
f(n)=bigrand()%n
```

> bigrand()返回很大的随机整数，当数据流到第n个数时，如果f(n)==0，则替换前面的已经选的随机数，这样可以保证每个数字被选中的概率都是1/n

## 随机选择 M 个数字

### 问题

程序输入包含两个整数m和n，其中m<n，输出是0~n-1范围内的m个随机整数的有序列表，不允许重复。从概率角度来说，我们希望得到没有重复的有序选择，其中每个选择出现的概率相等

### 方法一：无放回抽签模型——总数固定

先考虑个简单的例子，当m=2，n=5时，我们需要从0~4这5个整数中等概率的选取2个有序的整数，且不能重复。如果采用如下条件选取：

1. bigrand() % 5 < 2，则我们选取0的概率为2/5。
2. 但是我们不能采取同样的概率来选取1，因为选取了0后，我们应该以1/4的概率来选取1，而在没有选取0的情况下，我们应该以2/4的概率选取1。

> 只要满足条件m<=n，则程序输出m个有序整数，不多不少。不会多选，因为每选择一个数，select--，这样当select减到0后就不会再选了。同时，也不会少选，因为每次都会remaining--，当select/remaining=1时，一定会选取一个数。每个子集被选择的概率是相等的，比如这里5选2则共有C(5,2)=10个子集，如{0，1}，{0，2}...等，每个子集被选中的概率都是1/10。更一般的推导，n选m的子集数目一共有C(n,m)个，考虑一个特定的m序列，如0...m-1，则选取它的概率为m/n * (m-1)/(n-1)*....1/(n-m+1)=1/C(n,m)，可以看到概率是相等的。C++语言实现代码如下，该算法时间复杂度为O(n)。

```
void genknuth(int m, int n)
{ 
        for (int i=0; i<n; i++) 
            if (bigrand() % (n-i) < m) {  //n-i中i每次加1，相当于remaining每次减1
                 cout << i << endl;
                 m--;  //选取的数目减1
             }
}
```

### 方法二：取随机排序的前 m 个元素

采用前面随机排列数组的思想，先对前m个数字进行随机排列，然后排序这m个数字并输出即可。代码省略

## 从 rand 7 生成 rand 10

> https://blog.csdn.net/sgbfblog/article/details/7753012
>
> https://blog.csdn.net/sd4567855/article/details/87871049

```
//为了方便，粘贴自评论区。
/*
	a	1	2	3	4	5	6	7
b								
1		2	3	4	5	6	7	8
2		3	4	5	6	7	8	9
3		4	5	6	7	8	9	0
4		5	6	7	8	9	0	1
5		6	7	8	9	0	1	2
6		7	8	9	0	1	2	3
7		8	9	0	1	2	3	4

去掉右上角的  
6	7	8
7	8	9
8	9	0      后
每个数字的出现次数为4次，0-9的概率相同
*/
int rand10() {
        int a = rand7(), b= rand7();
        while( 1){
            if( !(a > 4 && b < 4))
                break;
            a = rand7(), b= rand7();
        }
            
        return (a+b) %10 + 1;
    }
}
```

## 生男生女问题

在重男轻女的国家里，男女的比例是多少？在一个重男轻女的国家里，每个家庭都想生男孩，如果他们生的孩子是女孩，就再生一个，直到生下的是男孩为止。这样的国家，男女比例会是多少？

> 还是1：1。在所有出生的第一个小孩中，男女比例是1：1；在所有出生的第二个小孩中，男女比例是1：1；.... 在所有出生的第n个小孩中，男女比例还是1：1。所以总的男女比例是1：1

## 抽样算法

## Sample的各种实现

　　在这之前，不妨考虑一下，如果要自己实现这个sample函数，那么有哪些方法呢。

　　我们首先放宽sample的定义，就是从有N个元素的序列中随机取出K个元素，不考虑是否影响原序列

### 第一种，随机抽取且不放回

　　跟抽牌一样，随机从序列中取出一个元素，同时从原序列中删除，那么不难验证每个元素被取出的概率都是K/N（N是序列长度），满足Sample需求。

　　若不考虑元素从列表中删除的代价，那么时间复杂度是O(K)。但问题也很明显，就是会修改原序列

### 第二种，随机抽取且放回

　　除了记录所有被选择的元素，还需要维护被选择的元素在序列中的位置(selected_pos_set)。随机从序列中取出一个元素，如果抽取到的元素的位置在selected_pos_set中，那么重新抽取；否则将新元素的位置放到selected_pos_set中。

　　不难发现，这个就是python random.sample代码中第二种实现。

　　这个算法的好处在于，不影响原序列。

　　那么时间复杂度呢？在抽取第i个元素的时候，抽取到重复位置元素的概率是(i - 1)/N，那么平均抽取次数就是N/(N - i +1)。那么抽取K个元素的平均抽取测试就是，sum（N/(N - i +1) ）， 1 <= i <= K; 等于N(logN - log(N-K+1)) 。当K等于N时，也就是NlogN

### 第三种，先shuffle整个序列，然后取前K个元素

　　算法的正确性很容易验证，时间复杂度是O(N)，而且原序列会被修改（乱序也算做修改）

### 第四种，部分shuffle，得到K个元素就返回

　　如果了解shuffle算法，那么算法理解还是很容易的。random.sample中第一种方案也是这样的算法。

　　单独实现这个算法的话就是这个样子的：

[![复制代码](随机算法.assets/copycode.gif)](javascript:void(0);)

```
1     def sample_with_shuffle(self, population, k):
2         n = len(population)
3         result = [None] * k
4         for i in xrange(k):         # invariant:  non-selected at [0,n-i)
5             j = int(random.random() * (n-i))
6             result[i] = population[j]
7             population[j] = population[n-i-1]   # move non-selected item into vacancy
8         return result
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　时间复杂度是O(K)，但缺点就是原序列会被改变。

### 第五种，水塘抽样算法

　　水塘抽样算法（[Reservoir_sampling](https://en.wikipedia.org/wiki/Reservoir_sampling)）解决的是 样本总体很大，无法一次性放进内存；或者是在数据流上的随机采样问题。即不管有多少个元素，被选中的K个元素都是等概率的。算法很巧妙，也是非常经典的面试题。

　　算法伪码是这样的：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 ReservoirSample(S[1..n], R[1..k])
 2   // fill the reservoir array
 3   for i = 1 to k
 4       R[i] := S[i]
 5 
 6   // replace elements with gradually decreasing probability
 7   for i = k+1 to n
 8     j := random(1, i)   // important: inclusive range
 9     if j <= k
10         R[j] := S[i]
```

[![复制代码](随机算法.assets/copycode.gif)](javascript:void(0);)

　　算法的时间复杂度是O(N)，且不会影响原序列。



> https://www.cnblogs.com/xybaby/p/8280936.html