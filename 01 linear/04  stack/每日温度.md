# 每日温度
> Author ID.9276 

**问题关键词：**

- stack
- DP

## 01 题目

根据每日 `气温` 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高的天数。如果之后都不会升高，请输入 `0` 来代替。

例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。

**提示：**`气温` 列表长度的范围是 `[1, 30000]`。每个气温的值的都是 `[30, 100]` 范围内的整数。

## 02 输入分析



## 03 解题思路

### 3.1 基础思路

#### 单调栈

- 结果数组初始化为 0
- 按照从左到右的顺序访问数组中的元素，使用一个从 top 到 bottum 递增的栈保存历史状态
  - 如果当前元素小于栈顶元素，无法计算当前元素的解，将当前元素入栈
  - 如果当前元素大于栈顶元素，**此时可以计算栈顶元素的解**（栈顶元素在当前元素之前入栈）
    - 我们此时可以确定栈顶元素的解，将栈顶元素弹出，计算二者距离，然后将当前元素入栈
- 遍历完成后对于栈中剩下的元素，不满足求解条件，因此其结果等于 0，也就是初始化的结果

#### DP

```java
/**
 * 根据题意，从最后一天推到第一天，这样会简单很多。因为最后一天显然不会再有升高的可能，结果直接为0。
 * 再看倒数第二天的温度，如果比倒数第一天低，那么答案显然为1，如果比倒数第一天高，又因为倒数第一天
 * 对应的结果为0，即表示之后不会再升高，所以倒数第二天的结果也应该为0。
 * 自此我们容易观察出规律，要求出第i天对应的结果，只需要知道第i+1天对应的结果就可以：
 * - 若T[i] < T[i+1]，那么res[i]=1；
 * - 若T[i] > T[i+1]
 *   - res[i+1]=0，那么res[i]=0;
 *   - res[i+1]!=0，那就比较T[i]和T[i+1+res[i+1]]（即将第i天的温度与比第i+1天大的那天的温度进行比较）
 */
```

### 3.2 算法优化



## 04 核心代码

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        stack<int> minStack;
        vector<int> ans(T.size(), 0);
        
        for(int i = 0; i < T.size(); i++) {
            while(!minStack.empty() && T[i] > T[minStack.top()]) {
                int tmp = minStack.top();
                minStack.pop();
                ans[tmp] = i - tmp;
            }
            minStack.push(i);
        }
        
        return ans;
    }
};
```



## 05 算法效率分析



## 06 问题总结

