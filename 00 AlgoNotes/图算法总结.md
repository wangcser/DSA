# 图算法总结

## 图的基础

### 图的输入：点数 + 边数 + 点对

图的输入：共有 2 × E + 2 个输入，E + 2 行

- 第一行代表点数 V
- 第二行代表边数 E
- 之后有 E 行点对

```
13
13
0 5
4 3
...
```

### 图的 API：关键在于邻接方法的实现

```
class Graph {
	Graph(int V)
	Graph(In in)
	int V()
	int E()
	void addEdge(int v, int u)
	iterable<int> adj(int v)
	string toString()
}
```

### 图的数据结构表示

- 邻接矩阵：
  - V×V 的布尔数组
  - 矩阵对于稀疏图和大图来说可能不现实
  - 无法表示平行边
- 边的数组
  - 定义一个 edge 类，使用两个 int 变量保存边
  - 对于 adj() 方法需要遍历整个边集
- 邻接表数组
  - 使用以顶点为索引的列表数组（顶点编号从 0 ～ V - 1），数组中每个元素是该顶点相邻接的顶点列表

## 无向图及其算法

### 无向图的表示：邻接表

邻接表的数据结构：

- 邻接操作：每个顶点及其相邻的顶点用链表表示
- 遍历操作：使用数组保存顶点（头指针）

邻接表的特点：

- 每条边会出现两次
- 空间正比于 V + E
- 加边操作为常数时间
- 遍历顶点 V 的 adj-node 正比于 V 的度
- 支持平行边和自环
- **边的插入顺序决定了数组中点的输入顺序，也代表了遍历时点的顺序**

邻接表结构的拓展：

- 支持点的添加与删除：将点数组改为符号表 ST，直接用点名进行检索
- 支持边的删除与查找：将链表替换为 set，此时数据结构变为邻接集
- 转化为符号图：增加两个数据结构来完成顶点名到顶点编号的映射
  - 符号表：string node_id ->int vertex_id
  - 反向索引： int vertex_id -> string node_id

图算法中常用的处理方法：查找-标记-计数

- search：连通性搜索，找到和输入的起点 s 连通的所有顶点
  - 使用 union-find 算法
- marked：联通点标记
- count：连通顶点的总数

### 深度优先搜索 DFS

算法：

- 访问当前节点并标记（最晚入栈的顶点）
- 递归访问当前节点所有没有被标记的节点
  - 从当前节点的 adj 中选择一个进行访问
  - 当访问到标记过的节点时，利用系统栈回退

辅助工具：

- 使用递归算法实现，借助系统调用栈即可

特点：

- 算法遍历顺序和图的表示有关
- 系统栈中存储了所有的分叉点

#### DFS：寻找图中到起点 s 的所有路径

- DSA
  - 使用一个 **uf 数组**，记录路径信息
  - 注意：**uf 是图中保存边结构的一种常用选择**
- DFS
  - 每遍历一条边 v-w，就将这条边放入 uf 数组：uf[w] = v
  - 注意这里的路径顺序是颠倒的
  - **uf 中生成的结果是以 s 为 root 的树**（得到一棵图的生成树）
- pathTo
  - 遍历 uf 数组，使用辅助栈恢复路径上节点的顺序

#### DFS：寻找图中的连通分量

- DSA
  - **uf 数组**，**直接用当前分量的 root 标记每个顶点的归属**
  - 连通分量的个数就是不同 root 的个数
  - count 变量，既是连通分量计数器，也是 uf 数组标志

- 对于这类问题我们一般用并查集完成

#### DFS：判断图中的是否有环

- 方法：
  - 对于 dfs ，要么深入，要么返回
  - **如果访问到已标记节点后都没有返回，说明入环了**

#### DFS：判断图是否是二分图

- DSA
  - uf 数组，保存每个点的颜色
- 方法：
  - 每次深入就覆盖边上两点的颜色
  - **遇到已经访问过的点就判断颜色是否相同，相同则不是二分图（不存在涂色方案）**

### 广度优先搜索：BFS

算法：

- 取队列中的下一个顶点（最早入队的顶点），访问并标记
- 将该顶点下未被标记的顶点加入队列

辅助工具：

- 队列

注意：

- 注意分层点的处理

#### BFS：单源最短路问题

DSA

- 使用 uf 维护路径信息（相当于层数）

## 有向图及其算法

### 有向图的表示：邻接表

表示：

- 有向图中的边是单向的，表示一个有序对
- 由第一个点（头）指出，由第二个点（尾）指入
- 两点间边的关系存在 4 种组合

邻接表 - > 没有了对称性

- 边链表只记录入节点
- 每条边只出现一次

有向图的 API：

- adj：返回指出的所有节点
- reverse：返回图的反转，可以用于求指入的所有节点

#### DFS：有向图的可达性

无向图中的连通性问题表示为有向图中的可达性问题，注意区别连通性和可达性

- DSA
  - 直接使用 DFS 即可
  - DFS 更适合有向图

应用：

- 内存中的垃圾回收
- 单点有向路径

#### BFS：单点最短有向路径

### 有向无环图 DAG

意义：DAG 为图结构引入了排序，这样的预处理可以大大优化很多算法

#### 拓扑排序：任务调度问题

问题：

- 给定一组任务，安排他们的执行顺序
- 任务具有不同的约束，最重要的一种为优先级限制
- 该问题可以建模为有向图模型

解法：

- 在有向图中，优先级限制下的调度问题等价于图中节点的拓扑排序
- 拓扑排序是该问题的一个解

#### 有向环的检测

- DSA
  - 使用 cycle 栈记录系统栈中的路径
  - 将 uf 数组中的结果导出
- DFS
  - 对于每一个入栈的元素，将其 uf 数组中的路劲导入 cycle 栈中

#### DAG 顶点的深度优先次序排序

- DSA
  - 在 DFS 算法中，将当前访问的参数顶点保存在一个数据结构中，遍历该结构就能得到一个顺序
- 保存的位置——遍历顺序
  - 前序，递归调用前入队
  - 后序，递归调用后入队
  - 逆后序，递归调用后入栈

#### 有向图的拓扑排序

定义：

- 给定一幅有向图，将所有顶点排序
- 所有有向边从排在前面的元素指向排在后面的元素
- 或者证明不存在这样的排序

性质：

- DAG 才存在拓扑排序
- 如果图中有有向环，则不存在拓扑排序

算法：

- DSA
  - 一幅 DAG 的拓扑排序就是所有顶点的逆后续排列（reversePost）

#### 优先级任务调度问题

思路：

- 检测环并去环
- 拓扑排序

算法：

- 定义任务和优先级
- 不断检测并去除环
- 对图进行拓扑排序

## 加权图及其算法

### 加权图的表示：邻接表

- 增加一列为边权

### 加权图与最小生成树 - 贪心算法

问题：

- 在一幅加权（权值各不相同）的连通无向图
- 求该图的最小生成树 MST

基础理论：

- 树中加边：产生环
- 树中删边：得到两棵树
- **图的切分：将图的两个顶点分为两个非空且不重合的集合**
- **图的横切边：连接两个集合顶点的边**

切分定理：

- 对于图的任意切分，横切边中的最小边必然属于 MST

基本算法：**贪心策略**

- 从树中点和非树中点的集合中找到一条最小横切边加入 MST，更新两个集合
- 一共找 V - 1 条边

加权无向图的数据类型：

- 邻接矩阵：将布尔值换为权重
- 邻接表：在 node 中增加一个权重域
- 邻接表 + 边类型：由于 MST 主要关注edge，因此将邻接表中的点类型换为边类型更好实现算法

#### Prim 算法：选边法

- DSA
  - 顶点数组：保存点集关系（也是一个 uf 数组）
  - 边：使用队列保存 MST 的边，或者用 uf 数组来保存边
  - 横切边：minPQ
- 算法
  - 每次选择一条最小**横切边**加入 MST 中
  - 维护 minPQ 中的切边集合，需要清理失效的切边（两点都在 MST 中的边）
- 延时实现：
  - 将新节点的邻接边都加入 minPQ 中，需要时再清理失效边
  - 时间复杂度 E
  - 空间复杂度 ElogE
- 即时实现：
  - minPQ 中只保存最小权的边，动态清理失效的边
  - 时间复杂度 V
  - 空间复杂度 ElogV

#### Kruskal 算法：排序避圈法

- DSA
  - 使用 minPQ 对边排序
  - 使用 uf 来识别环
  - 使用 queue 来保存 MST
- 算法
  - 按照所有边的边权顺序将边加入 MST 中，不加入将树引入环的边
  - 知道 V - 1 条边为止
- 实现
  - 时间复杂度 V
  - 空间复杂度 E + VlogV

### 加权图与最短路

单点最短路问题：

- 如果存在，找到一个顶点到达另一个顶点的成本最小的路径

最短路问题的性质：

- 路径有向
- 权重和距离无关
- 不是所有节点都可达
- 负权重使问题更复杂
- 最短路不一定唯一
- 可能存在平行边和自环
- 可能存在 0 权重圈

最短路径树：

- 所有从起点 s 出发的最短路构成了一个以 s 为 root 的最短路径树
- DSA
  - 定义有向边类型 DirectedEdge，含有三个变量，用该类型替换图模型中的点类型
    - weight
    - from
    - to
  - 使用 uf 数组保存最短路径
  - 使用 数组记录每个点到起点的距离
- Relax：松弛操作——每次松弛都会更新最短路
  - 边的松弛：如果到达当前点的代价小于已有的代价，则更新当前边到最短路集合
  - 点的松弛：如果点的邻接边中有比已有代价更好的边，则更新当前所有边到最短路集合
  - 更新是指加入一些边并去掉一些边
  - 放松操作只会减小 distTo 中的代价值

#### 边权非负的最短路算法：Dijkstra 算法（边权非负，可以有环）—— OSPF

- 思想
  - 在最短路中任意可达两点间的代价都不大于这两点间的所有路
  - **即局部最短必然导致全局最短**
- DSA
  - distTo 数组记录每个点到起点的当前最短距离
  - edgeTo 数组记录最短路径树
  - minPQ 记录当前被放松的点
- 算法
  - 将起点的代价初始化为 0，其他点初始化为 POSITIVE_MAX
  - 将起点松弛加入树中
  - 选择代价最小的非树顶点放松并加入树中
    - 松弛点由 minPQ 根据当前非树点的代价产生
    - 松弛操作将遍历松弛点可达的下一个点的代价并更新
  - 直到所有顶点都在树中或者所有非树顶点的代价都是 POSITIVE_MAX
- 性能
  - 时间复杂度 ElogV
  - 空间复杂度 V
- 特点
  - 类似 Prim 算法
- 变种
  - 无向图的最短路
    - 无向边转化为双向边即可
  - 给定两点的最短路
    - 找到 dst 后提前终止算法即可
    - 或者使用单点最短路算法求出所有的解之后进行查询
  - 任意点对之间的最短路
    - 对每一个点对重复上面的过程
    - 注意，不同起点会生成不同的 SPT
  - 欧几里得图中的最短路
    - 该算法可优化

#### 无环加权有向图中的最短路算法（边权可负，必须无环）

- 思想
  - 顶点放松
  - 拓扑排序（v 被放松后就不会再更新 distTo[v]）
- 算法
  - 由 DFS 对图进行拓扑排序
  - 按拓扑顺序依次松弛图中的点
- 性能
  - 时间复杂度 E + V（拓扑排序的开销）
    - 松弛过程复杂度为 E
- 特点
  - 无环约束保证了能够进行拓扑排序
  - 性能在该条件下最优
  - 没有要求权值非负，因此可以处理负权值问题
- 变种
  - 寻找无环加权有向图的单点最长路
    - 权重取反（因为这个算法对负数也有效）
    - 有环的情况是一个 NP 问题
  - 优先级限制下的并行任务调度：求最短完成时间（处理器数量不限）
    - 最短完成时间的下限是假设所有任务都可并行，因此取决于最耗时的任务
    - 最短完成时间的上限是 max(关键路径耗时，最长任务耗时)
    - 关键路径指任务中必须穿行执行的任务序列，这等价于上面的长路径问题
    - 这个问题难在规约建模

#### 通用最短路算法：Bellman-Ford 算法（判断负权环）—— 距离矢量算法

特点：

- 适用于含有负权重和环的情况
- 能够求解负权边的图
- 能够求解含环的图
- **能判断含负权环的图**，不能求解含负权环的图

对最短路的理解：

- 负权重：是的算法为了经过负权重而绕弯
- 负权重环：使得经过环的最短路不存在，一般来源于现实中的输入错误（只有产生负权重环才会导致求解失败哦）

求解目标：

- 检测负权重环，若存在则不存在单源最短路解
- 求解无负权重环下的最短路

实现：

- DSA
  - 使用 queue 收集由更新边引入的点
  - 使用 标记数组标记点是否在 queue 中，防止重复处理
  - 只进行 V 次（有环的嘛）
- 求最短路的算法
  - 
- 检测负权环的算法
  - 假设存在最短路和 SPT，路中不包含回路，对于 V 个点最多只有 V - 1 条边，每次松弛一条边且不会重复松弛
  - 因此我们只进行 V 次，如果不进行限制算法可能无法终止
  - 另一方面来看，算法终止时 queue 中无剩余，代表无环，反之有环
- 性能
  - 时间复杂度 EV
  - 空间复杂度 V

总结：

- 对 relax 的封装使得三种算法都十分简洁
- 三种 SP 算法在实现上的区别在遍历边的顺序不同

#### 含负环的最短路算法：SPFA 算法（队列优化的 BF 算法）

- 用途：
  - 可用于求解含负权的最短路

#### 任意两点最短路算法：Floyd-Warshall 算法（多源最短路）

### 小结

1.广度优先算法BFS主要适用于无权重向图重搜索出源点到终点的步骤最少的路径，当方向图存在权重时，不再适用

2.狄克斯特拉算法Dijkstra主要用于有权重的方向图中搜索出最短路径，但不适合于有负权重的情况.对于环图，个人感觉和BFS一样，标志好已处理的节点避免进入死循环，可以支持

3.贝尔曼-福特算法Bellman–Ford主要用于存在负权重的方向图中(没有负权重也可以用，但是效率比Dijkstra低很多)，搜索出源点到各个节点的最短路径

4.Bellman–Ford可以判断出图是否存在负环路，但存在负环路的情况下不支持计算出各个节点的最短路径。只需要在结束(节点数目-1)次遍历后，再执行一次遍历，若还可以更新数据则说明存在负环路

5.当人为限制了遍历次数后，对于负环路也可以计算出，但似乎没啥实际意义


作者：CodeInfo链接：https://juejin.im/post/5b77fec1e51d4538cf53be68来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。