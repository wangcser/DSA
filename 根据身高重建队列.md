# 根据身高重建队列
> Author ID.9276

## 01 题目

假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对`(h, k)`表示，其中`h`是这个人的身高，`k`是排在这个人前面且身高大于或等于`h`的人数。 编写一个算法来重建这个队列。

**注意：**
总人数少于1100人。

**示例**

```
输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

## 02 分析

先对输入数组排序，h升序，k降序 从头循环遍历 当前这个人就是剩下未安排的人中最矮的人，**他的k值就代表他在剩余空位的索引值** 如果有多个人高度相同，要按照k值从大到小领取索引值 示例：

```json
[ 0, 1, 2, 3, 4, 5 ] [ 4, 4 ] 4
[ 0, 1, 2, 3, 5 ]    [ 5, 2 ] 2
[ 0, 1, 3, 5 ]       [ 5, 0 ] 0
[ 1, 3, 5 ]          [ 6, 1 ] 3
[ 1, 5 ]             [ 7, 1 ] 5
[ 1 ]                [ 7, 0 ] 1
[ [ 5, 0 ], [ 7, 0 ], [ 5, 2 ], [ 6, 1 ], [ 4, 4 ], [ 7, 1 ] ]
```

下面的解法反映了这个思路，注意两点：

1. stl 中排序模版的使用
2. 在下面的实现中，由于使用了空容器，因此不需要计算相对位置，每次插入的时候都就绪了（空容器也可以在指定位置插入？？？）



## 03 题解

### 3.1 C++

```c++
//version 1.0 0.0%
class Solution {
public:
    vector<pair<int, int>> reconstructQueue(vector<pair<int, int>>& people) {
        
        vector<pair<int, int>> result;
        sort(people.begin(), people.end(), 
             [](const pair<int, int>& a, const pair<int, int>& b) {
                 return a.first > b.first || (a.first == b.first && a.second < b.second);
             });
        
        for(auto p : people) {
            result.insert(result.begin() + p.second, p);
        }
        
        return result;
    }
};
```

### 3.2 Python 3

```python
# version 1.0 0.0%

```

### 3.3 Go

```Go
//version 1.0 0.0%

```



## 04 总结

