# 常用算法设计技巧总结

针对不同类型的问题常常会有不同的算法设计技巧，本文对我在算法设计实践中遇到过的技巧进行了总结和归纳。

## 使用数组下标构建 hash 表

数组的下标是一个隐含的很有用的数组，特别是在统计一些数字，或者判断一些整型数是否出现过的时候。例如，给你一串字母，让你判断这些字母出现的次数时，我们就可以把这些字母作为**下标**，在遍历的时候，如果字母a遍历到，则arr[a]就可以加1了，即  arr[a]++;

通过这种巧用下标的方法，我们不需要逐个字母去判断。

```
public void f(int arr[]) {

       int[] temp = new int[21];
       for (int i = 0; i < arr.length; i++) {
           temp[arr[i]]++;
       }
       //顺序打印
       for (int i = 0; i < 21; i++) {
           for (int j = 0; j < temp[i]; j++) {
               System.out.println(i);
           }
       }
   }
```



## 使用取余优化边界检查

有时候我们在遍历数组的时候，会进行越界判断，如果下标差不多要越界了，我们就把它置为0重新遍历。特别是在一些环形的数组中，例如用数组实现的队列。往往会写出这样的代码：



```
for (int i = 0; i < N; i++) {
       if (pos < N) {
        //没有越界
        // 使用数组arr[pos]
        else {
          pos = 0;//置为0再使用数组
          //使用arr[pos]
         }
        pos++;
   }
```



实际上我们可以通过取余的方法来简化代码



```
for (int i = 0; i < N; i++) {
  //使用数组arr[pos]   (我们假设刚开始的时候pos < N)
  pos = (pos + 1) % N;
}
```

## 使用双指针记录链表的状态

对于双指针，在做关于单链表的题是特别有用，比如“判断单链表是否有环”、“如何一次遍历就找到链表中间位置节点”、“单链表中倒数第 k 个节点”等问题。对于这种问题，我们就可以使用双指针了，会方便很多。

## 使用移位运算加速算术运算

有时候我们在进行除数或乘数运算的时候，例如n / 2，n / 4, n / 8这些运算的时候，我们就可以用移位的方法来运算了，这样会快很多。



例如:



n / 2 等价于 n >> 1

n / 4 等价于 n >> 2

n / 8 等价于 n >> 3

还有一些 &(与)、|(或)的运算，也可以加快运算的速度。例如判断一个数是否是奇数，你可能会这样做



```
if(n % 2 == 1){
 dosomething();
}
```



不过我们用与或运算的话会快很多。例如判断是否是奇数，我们就可以把n和1相与了，如果结果为1，则是奇数，否则就不会。即



```
if(n & 1 == 1){
 dosomething();
)
```



具体的一些运算技巧，还得需要你们多在实践中尝试着去使用，这样用久后就会比较熟练了

## 设置哨兵位避免特殊情况处理和边界检查

在链表的相关问题中，我们经常会设置一个头指针，而且这个头指针是不存任何有效数据的，只是为了操作方便，这个头指针我们就可以称之为哨兵位了。



例如我们要删除头第一个节点是时候，如果没有设置一个哨兵位，那么在操作上，它会与删除第二个节点的操作有所不同。但是我们设置了哨兵，那么删除第一个节点和删除第二个节点那么在操作上就一样了，不用做额外的判断。当然，插入节点的时候也一样

有时候我们在操作数组的时候，也是可以设置一个哨兵的，把arr[0]作为哨兵。例如，要判断两个相邻的元素是否相等时，设置了哨兵就不怕越界等问题了，可以直接arr[i] == arr[i-1]?了。不用怕i = 0时出现越界

## 递归求解优化

1. 缓存中间状态
2. 改进为迭代算法

## Reference

<https://mp.weixin.qq.com/s/6JJdV9oXJznkGt4gSOlR9g>