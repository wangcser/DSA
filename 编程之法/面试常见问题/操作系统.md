# 操作系统

## 互斥条件与死锁

请问死锁的条件是什么？以及如何处理死锁问题？

- 定义
  - 两个或两个以上的进程在执行的过程中，因为争夺资源而造成的一种相互等待的现象
- 原因
  - 系统资源不足
  - 资源分配不当
  - 进程的运行顺序不合适
- 产生的必要条件：互斥条件（Mutual exclusion）：
  - **互斥**：资源不能被共享，只能由一个进程使用。
  - **占用且等待**：请求与保持条件（Hold and wait）：已经得到资源的进程可以再次申请新的资源。
  - **不可强占**：非剥夺条件（No pre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。
  - **循环等待**：循环等待条件（Circular wait）：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源
- 如何处理死锁问题：
  - 不管：**忽略该问题**。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。
  - 预防：**仔细地对资源进行动态分配，以避免死锁**。对资源分配进行合理规划
  - 检测：**检测死锁并且恢复**。允许系统发生死锁。
    - 常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。死锁检测盒解除有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大
  - 预防：**通过破除死锁四个必要条件之一，来防止死锁产生**。

**处理死锁的基本方法**：

***死锁预防**：通过设置某些限制条件，去破坏死锁的四个条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而导致系统资源利用率和系统吞吐量降低。

***死锁避免**：允许前三个必要条件，但通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发。

***死锁检测**：不须实现采取任何限制性措施，而是允许系统在运行过程发生死锁，但可通过系统设置的检测机构及时检测出死锁的发生，并精确地确定于死锁相关的进程和资源，然后采取适当的措施，从系统中将已发生的死锁清除掉。

***死锁解除**：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。死锁检测盒解除有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。



二 死锁预防：破坏死锁的四个条件中的一个或几个。

(1)互斥：它是设备的固有属性所决定的，不仅不能改变，还应该加以保证。

(2)占有且等待：

为预防占有且等待条件，可以要求进程一次性的请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足。这个方法比较低效。

(3)不可抢占：

预防这个条件的方法：

*如果占有某些资源的一个进程进行进一步资源请求时被拒绝，则该进程必须释放它最初占有的资源。

*如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另外一个进程，要求它释放资源。

(4)循环等待：通过定义资源类型的线性顺序来预防。

*如果一个进程已经分配了R类资源，那么接下来请求的资源只能是那些排在R类型之后的资源类型。该方法比较低效。



三 **死锁避免**：

(1)两种死锁避免算法：

*进程启动拒绝：如果一个进程的请求会导致死锁，则不启动该进程。

*资源分配拒绝：如果一个进程增加的资源请求会导致死锁，则不允许此分配(**银行家算法**)。



(2)**银行家算法**：

1.如果request<=need，转向步骤2；否则认为出错，因为请求资源大于需要资源。

2.如果request<=available，转向步骤3,；否则尚无足够资源，进程p阻塞；

3.系统尝试为把资源分配给进程P，并修改available、allocation和need的数值。

4.系统执行安全性算法，检查此次分配后系统是否处于安全状态，若安全，才正式将资源分配给进程P，否则将本次试探性分配作废，让进程P等待。

*安全状态：系统能按照某种进程顺序，为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成。



(3)安全性算法：

1.设置两个向量：

*工作向量work：表示系统可提供给进程继续运行的所需的各类资源的数目，执行安全算法开始时，work=available。

*finish：表示系统是否有足够资源分配给进程，使之运行完成。开始时先做finish[i]=false；当有足够资源分配给进程时再令finish[i]=true。

2.从进程集合找到一个满足下列条件的进程：

*finish[i]=false；

*need<=work；

*若找到执行步骤3；否则执行步骤4；

3.当进程P获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：

*work=work+allocation(P)；

*finish[i]=true；

*循环执行步骤2；

4.如果所有进程的finish=true，则表示系统处于安全状态；否则，系统处于不安全状态。



四 死锁检测和解除

(1)死锁检测算法。

(2)死锁的解除：

*两种常用的死锁解除方法：剥夺资源和撤销进程。



## 请阐述动态链接库与静态链接库的区别

解答：

- **静态链接库是.lib格式的文件，程序编译时会把lib文件的代码加入你的程序中因此会增加代码大小，你的程序一运行lib代码强制被装入你程序的运行空间，不能手动移除lib代码**。

- **动态链接库是程序运行时动态装入内存的模块，格式*.dll，在程序运行时可以随意加载和移除，节省内存空间**。

在大型的软件项目中一般要实现很多功能，如果把所有单独的功能写成一个个lib文件的话，程序运行的时候要占用很大的内存空间，导致运行缓慢；但是如果将功能写成dll文件，就可以在用到该功能的时候调用功能对应的dll文件，不用这个功能时将dll文件移除内存，这样可以节省内存空间。

## 请阐述进程与线程的区别

解答：

- ①从概念上：
  - 进程：一个程序对一个数据集的动态执行过程，是分配资源的基本单位。
  - 线程：一个进程内的基本调度单位。线程的划分尺度小于进程，一个进程包含一个或者更多的线程。
- ②从执行过程中来看：
  - 进程：拥有独立的内存单元，而多个线程共享内存，从而提高了应用程序的运行效率。
  - 线程：每一个独立的线程，都有一个程序运行的入口、顺序执行序列、和程序的出口。但是线程不能够独立的执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
- ③从逻辑角度来看（重要区别）：
  - 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但是，操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理及资源分配。

## 用户进程间通信主要哪几种方式？

解答：主要有以下6种：

- **管道**：**管道是单向的、先进先出的、无结构的、固定大小的字节流**，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的道端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。
  - 无名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系（通常是指父子进程关系）的进程间使用。
  - 命名管道：命名管道也是半双工的通信方式，在文件系统中作为一个特殊的设备文件而存在，但是它允许无亲缘关系进程间的通信。当共享管道的进程执行完所有的I/O操作以后，命名管道将继续保存在文件系统中以便以后使用。
- **信号量**：**信号量是一个计数器，可以用来控制多个进程对共享资源的访问**。它常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- **消息队列**：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- **信号**：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- **共享内存**：共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其它进程间通信方式运行效率低而专门设计的。它往往与其它通信机制（如信号量）配合使用，来实现进程间的同步和通信。
- **套接字**：套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。