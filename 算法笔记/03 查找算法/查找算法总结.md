# 查找算法

[TOC]



## 符号表

符号表是 <key, value> 的集合，有多种数据结构的实现，查找问题，就是对符号表中的 key 进行访问，查找其 value 的过程

高效的查找算法，依赖于：

- 数据结构
- 插入 out
- 查找 get

有序的符号表只能够按 key 排序的符号表，他能够提供更多的应用，此时引入了新的 API 支持：

- 最小 key
- 最大 key
- 排名
- 选择

算法需求：

- 构造庞大符号表的同时能够支持高效的插入/删除键值对，同时还要能够完成高效的查找操作

算法关键操作：

- 比较

## 无序符号表下的查找算法

### 无序链表 + 顺序查找

实现：

- DSA
  - 单向链表，数据区由两个字段构成：key, value
- get 
  - 遍历链表
- put
  - 遍历链表，存在则更新，否则在头部插入新的节点

性能：

- 未命中的查找和插入需要 N 次比较
- 随机命中需要 N/2 次比较
- 向空表插入 N 个不同的 key 需要 N^2/2 次比较

## 有序符号表下的查找算法

### 有序数组 + 二分查找

实现：

- DSA
  - 一对平行数组，一个存储 key， 一个存储 value
- rank
  - 基于二分查找算法，无论 key 存在与否，返回数组中小于给定 key 的键的数量（key 的 index）
- put
  - 由 rank 的返回值确定插入的位置，更新已有的值或是动态插入新的值
- get
  - 由 rank 的返回值确定查找的结果

性能：

- 二分查找有效减少了比较的次数，为 log N 级别
- 插入操作最坏情况下达到 N^2 级别（N个数，每次都要在数组的顺序头部插入 log N 次比较和 N 次移动）

总结：改进了比较操作

### 二叉查找树 BST

- 链表插入的灵活性
- 有序数组查找的高效性

实现：

- DSA
  - 一棵二叉树，每个节点存储可比较的 key 和 value
  - left->key <= root->key <= right->key
  - 节点内维护一个节点计数器，保存以该节点为 root 的子树中所有节点的数量（简化了很多操作）
- get
  - 子树为空（leaf），则未命中
  - root->key = key，命中
  - root->key > key，递归查找左子树
  - root->key < key，递归查找右子树
- put
  - 子树为空，则在当前位置插入新节点
  - root->key = key，更新 value
  - root->key > key，递归查找左子树，更新左链接
  - root->key < key，递归查找右子树，更新右链接
  - 更新节点计数器

性能：

- 取决于树的形状，树的形状取决于 key 插入的先后顺序
  - 最好情况，树完全平衡，树高 logN
  - 最坏情况，树退化为链表，树高 N
- 查找命中的平均比较次数为 lnN
- 插入操作和查找未命中的平均比较次数为 lnN

删除操作：

- delMin：删除最小键（仅含右子树）
  - 找到树中最左侧的节点，该节点处为最小键
  - 将指向该节点的链接更新为指向该节点的右子树（该节点没有左子树）
  - 向上更新父节点的链接和计数器
- del：删除任意节点（含有左右子树），Hibbard 后继删除法 
  - 找到待删除的节点，保存指向该节点的链接（用于更新其左右子树）
  - 使用该节点的后继节点替换被删除节点，这个节点会被函数返回（后继节点为在该节点的右子树中的最小键节点，找到后保留指向该节点的链接）
  - 后继节点的右子树 = 被删除节点更新后的右子树（删除了后继节点）
  - 后继节点的左子树 = 被删除节点的左子树
  - 向上更新父节点的链接和计数器

删除操作的性能：

- Hibbard 删除法没有考虑到树的对称性

总结：

- 在一棵二叉查找树中，所有操作的最坏情况都与树高成正比

### 平衡树：2-3 树

树为**完美平衡**的：任意空连接到 root 的路上的链接数相同

- DSA
  - 树中存在 2 节点或者是 3 节点
  - 对于 3 节点，两个 key 之间存在一条链接指向二者 key 之间的子树
- get
  - 同 BST
- put
  - 插入之前进行一次未命中的查找，得到插入的位置
  - 分情况进行，下面简要总结

**2-3 树中的插入（平衡插入）**

- 向 2 节点中插入新键：**插入点树高不变**
  - 将 2 节点替换为 3 节点，将新 key 插入 3 节点中
- **向一棵只含有 3 节点的树**插入新键：插入点树高 + 1
  - 将新 key 插入 3 节点成为 4 节点，含有 3 个 key 和 4 条边
  - 将 4 节点拆分为一个由 3 个 2 节点构成的 2-3 子树
    - **中 key 为子树 root**
    - 左 key即其左右链接构成 root->left
    - 右 key即其左右链接构成 root->right
- 向一个父节点为 2 节点的 3节点插入新键：插入点及其父节点树高不变（**核心操作**）
  - 将新 key 插入 3 节点成为 4 节点，含有 3 个 key 和 4 条边，此时父节点为 2 节点，含有 1 个 key 和 2 条链接，其中一个链接指向 4 节点（原来的三节点）
  - 将 4 节点拆分为一个由 3 个 2 节点构成的 2-3 子树，**将树根合并到父节点**使父节点变成一个 3 节点
- 向一个父节点为 3 节点的 3 节点插入新键：树高不变或 + 1
  - 将新 key 插入 3 节点成为 4 节点
  - 分解 4 节点，将其中 key 插入其父亲，构造新的 4 节点
  - 依次向上传播，直到某个 2 节点或者非 2 节点的 root
    - 存在 2 节点，采用第一种处理策略，2 节点变为 3 节点，树高不变
    - 从插入点到 root 全为 3 节点，调整后 root 变为 4 节点，采用第二种策略，将 root 拆分为一个由 3 个 2 节点构成的 2-3 子树，树高 + 1

**局部变换**：将 4 节点分解为 2-3 树——6 种情况

- 4 节点为 root
  - 中键变为新树的 root，左右键及其两条链接变为新树的左右子树
- 4 节点为 2 节点的左子节点
  - 中键子树合并到 2 节点左侧
- 4 节点为 2 节点的右子节点
  - 中键子树合并到 2 节点右侧
- 4 节点为 3 节点的左子节点
  - 中键子树合并到 3 节点左侧
- 4 节点为 3 节点的中子节点
  - 中键子树合并到 3 节点中间，变为 4 节点的中 key
- 4 节点为 3 节点的右子节点
  - 中键子树合并到 3 节点右侧

局部变换的特点：

- 修改在树的局部进行
- 不影响树的全局有序性
- 不影响树的全局平衡性（不是说树高不变哦）

2-3 树的全局性质：

- 任意空节点到 root 的路径的长度都是相等的
- 只有当分解 root 4 节点时，新树的树高才 + 1，其他情况树高不变
- 2-3 树的生长是由下向上的 

性能：

- 查找和插入操作的访问节点不超过 logN 个

缺点：

- 不利于实现

2-3 树的插入算法总结：

- 构建：插入节点后产生 3 节点或 4 节点
- 分解：分解 4 节点，将中间 key 插入父节点
- 传递：直到 2 节点或 root

### 平衡树： RB 树

考虑到 2-3 树实现的复杂性，我们使用 RB-BST 来表达和实现它

基本思想：

- 用标准 BST + 额外信息表示 2-3 树
- 红链接将两个 2 节点链接起来构成一个 3 节点
- 黑链接表示 2-3 树中的普通链接

2-3 树 3 节点转换为 RB 树节点的方法：

- 拆分：将 3 节点左侧 key 及其两边的链接拆分出来
- 左斜：作为一个新的 2 节点作为原来右侧 key 的左子树
- 二者用红色链接表示

定义：

- 含有红黑链接 —— 红黑树的颜色指其链接的颜色！
- 红链接均为左链接
- 没有任何一个节点同时和两个红链接相连
- 树为完美黑色平衡的：任意空连接到 root 的路上的黑链接数相同

分析：

- 如果将红黑树中红链接拉平，或者将红链接合并，得到一颗 2-3 树
- 由 2-3 树构造红黑树的方法决定了不存在两个红链接和一个节点相连（产生 >4 节点？）
- 红黑树中的黑链接就是 2-3 树中的普通链接，具有完美平衡性

颜色表示：

- 在链接指向的节点内维护链接的颜色（bool）
- 访问方式：node->left->color == RED (bool RED = 1)

旋转操作：用于修复红色右链接或梁旭两条红色链接

- 左旋：
  - 此时指向节点的链接是右链接
  - 将右节点的左子树交给父节点，作为其右子树
  - 将指向其父的链接改到该链接上（指向 2-3 树中的右侧键）
- 右旋：
  - 此时指向节点的链接左右链接
  - 将左节点的右子树交给父节点，作为其左子树
  - 将指向其父的链接改到该链接上（指向 2-3 树中的左侧键）

- 实现细节：
  - 旋转后的节点复制父亲链接的颜色
  - 更新二者的计数器
  - 旋转操作返回一条链接（一个节点），用该链接重置父节点的链接

- DSA
  - BST Tree Node
  - color flag
- get
  - 同 BST
- put
  - 插入之前进行一次未命中的查找，得到插入的位置
  - 分情况进行，下面简要总结

红黑树中的插入

- 向单个 2 节点中插入新键：只含有一个键（root）的 RB 树，黑链接高度不变
  - 新键小于老键：
    - 左侧插入红节点（红链接）
  - 新键大于老键：
    - 右侧插入红节点（红链接）
    - 旋转并更新链接： root = rotateLeft(root)
- 向树底部的 2 节点插入新键：黑链接高度不变
  - 方法同上
  - 注意新节点以红链接的方式插入，因此不会改变树高

- 向一棵双键树（3 节点）中插入新键：3 种情况，子树高度 + 1
  - 新键大于原树中两键：子树高度 + 1
    - 被连接到最右边的空连接（3 节点的右链接），此时新树的根节点为中间 key
    - 进行**颜色转换**，将两条红链接变黑，得到平衡树
  - 新键小于原树中两键：子树高度 + 1
    - 被连接到最左边的空连接，产生连续两条左红链接
    - 右旋上层左红链接，回到大于的情况
  - 新键位于原树之间：子树高度 + 1
    - 新键插入红节点的右链接下，产生右红链接（以及上层的左红链接）
    - 左旋当前的右红链接，回到小于的情况
    - 右旋上层左红链接，回到大于的情况
- 插入过程中的颜色转换：
  - 同时翻转子节点父节点的颜色（将插入传递到父节点）
  - 每次插入后检查根节点，若为红色，则将根节点置为黑色，每次根节点由红变黑则树高 + 1

一个一般性的插入过程：

- 向树底部的 3 节点插入新键：相当于将插入的链接转移到 3 节点的中间链接，也就是将中间 key 变红
  - 新节点链接为右链接：
    - 转换颜色
  - 新节点链接为左链接：
    - 右旋
    - 转换颜色
  - 新节点链接为中链接：
    - 下层左旋
    - 上层右旋
    - 转换颜色
- 将红链接在树中向上传递：总结为下面的三条规则
  - 右子节点为红而左子节点为黑，左旋 —— 构建 4 节点
  - 左子节点为红且左左为红，右旋 —— 分解 4 节点
  - 左右都为红，颜色转换 —— 传递 4 节点

RB 树的删除操作 —— 借鉴下面的先构造平衡结构再回溯恢复的思路

- 2-3-4 树的插入操作：

  - 自顶向下：
    - 分解 4 节点，将其中键加入其父亲（可能引入新的 4 节点，不管）
    - 到达底部后插入新键

- 用 BR 树表示 2-3-4 树的插入算法：

  - 自顶向下：
    - 分解 4 节点，颜色转换
  - 自底向上：
    - 用旋转配平 4 节点

  2-3 树中删除最小键算法：

  - 先自顶向下构造兄弟结构，保证路径上不存在 2 节点
  - 树底最小键节点变为 3 节点或 4 节点，直接删除左侧键即可
  - 再自底向上分解过程中产生的临时 4 节点

RB 树的性能：

- 无论键的插入顺序如何，树都是近似完美平衡的
- 第一种能够同时高效实现查找、插入和删除操作的符号表实现
- 查找性能比 BST 快（平衡性）
- 所有操作运行时间都是对数级别的

RB 树的特点：

- 仅 put 和 delete 方法比较复杂
- 其他 BST API 和实现都可直接使用

## 散列表

基于散列的查找算法分为两步：

- 用散列函数将键转化为索引
- 处理散列的碰撞冲突
  - 拉链法
  - 线性探查法

特点：

- 支持和数组大小无关的常数时间级别的插入和查找操作
- 无法支持顺序性操作
- 算法取决于散列函数的性能

### 散列函数

函数特点：

- 输入 key，输出 index（index 指一个数）
- 易于计算
- 能够均匀分布所有的 key
- 函数和 key 的类型有关

函数举例

- 整数：除留余数法
  - 散列表选择大小为素数 M 的数组（其散列值分布更好）
  - 计算 k % M
- 浮点数：除留余数法
  - 将键表示为二进制
  - 使用除留余数法
- 字符串：
  - 除留余数法：将字符串当做大整数（N 位 R 进制数，按位散列求和）
  - Horner 方法
- 组合键：
  - 如果键含有多种整型变量，就和 string 一样混合即可（N 位 R 进制数）

实现技巧：

- 使用软缓存在 key 中缓存其 hashcode， 而不是每次都重新计算

## 散列表下的查找算法

### 数组散列表

对于键都是小整数的情况，可以使用数组实现散列表

- 键为数组的索引
- 这个简单的实现一般用于没有碰撞的情况

### 基于拉链法的散列表

处理碰撞的方法：

- 将散列数组中每个元素指向一个链表（或其他符号表）
- 在链表中存储碰撞元素的 index，key，value

算法

- put
  - 依据散列值选择链表尾部插入
- get
  - 从其散列值开始顺序查找，找到则命中，遇到 NULL 则未命中
- delete
  - 链表删除

性能：

- 链表平均长度为 N / M，因此，尽量选择较大的素数 M
- 顺序性操作：
  - 散列表将 key 均匀地散步开后丢失了 key 的顺序信息，因此顺序性操作具有线性时间

### 基于线性探查法的散列表

处理碰撞的方法：

- 用 M 大小的数组保存 N 对 key-value，其中 M > N
- 使用数组中的空位解决冲突

线性探查法：

- 发生碰撞时继续检查散列表的下一位（index + 1），有三种可能：
  - 命中
  - 未命中，当前 key 为空
  - 继续探查，key 不为空但和查找的 key 不同

算法：

- put
  - 顺序查找空元素插入
- get
  - 从其散列值开始顺序查找，找到则命中，遇到空元素则未命中
- delete
  - 将表中被删除键右侧所有的键重新插入散列表
- 调整数组大小
  - 先申请新的空间
  - 在对源空间的数据重新散列装入新空间

性能：

- 散列表空间占用率 N / M，该值小于 1
- 占用率不能 = 1，为了保证性能需要动态调整数组大小保证占用率在 1/8 到 1/2 之间，这个值保证探测的预计次数在 1.5~2.5
- 探查的平均成本取决于键簇（连续的条目），短小的键簇才能保证较高的效率