# 寻找最小的K个数
> Author ID.9276 

**问题关键词：**

- 

## 01 题目

输入n个整数，输出其中最小的k个。

## 02 输入分析



## 03 解题思路

### 3.1 基础解法 - 排序

- 算法
  - 先增序排序：快排，归并
  - 再输出序列前 k 个元素
- 复杂度
  - 时间：O(nlogn + k)
  - 空间： O(1)

### 3.2 优化

#### 类最大堆

- 分析
  - 并未要求各部分有序，只需要保证这 k 个数比剩下的 n-k 个数小即可

- 算法
  - 遍历序列，将前 k 个数存入容量为 k 的数组中，假设他们为最小的 k 个数
  - 定义操作 findMax，从 k 个数中找到最大的元素 kmax，该操作时间复杂度为 O(k)
    - 这里不用 sort 是因为 sort 复杂度更高
  - 继续遍历剩下的序列，将每一次遍历的元素 x 和 kmax 比较，若
    - x < kmax，则用 x 替换 kmax，此时 k 数组改变，需要求出新的 kmax’
    - 否则，继续遍历即可
- 证明：交换完毕后 n-k 个数都比 k 数组中的 kmax 大
- 复杂度
  - 时间：O(n*k)
  - 空间：O(k)，可以使用 inplace 的方法，在原序列上 swap 即可，改进为 O(1)

#### 最大堆

- 分析
  - 上面的方法类似于堆排序，因此我们直接用堆结构即可
- 算法
  - 用容量为k的最大堆存储最先遍历到的k个数，同样假设它们即是最小的k个数
  - 堆中元素是有序的，令k1<k2<...<kmax（kmax设为最大堆中的最大元素）
  - 遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与堆顶元素kmax比较：
    - 如果`x < kmax`，用x替换kmax，然后更新堆（用时logk）
    - 否则不更新堆
- 复杂度
  - 时间：O(nlogk)，得益于堆结构更新和查找的效率为 O(logk)
  - 空间：O(k)，堆的开销，同理，也可以改进为 inplace 的方法

#### 快速选择法

- 分析
  - 假设序列有序，则最小的 k 个数就是序列最前面的 k 个数，也就是位于 k+1 元素之前的序列
  - 考虑快速排序直接求出枢轴 k+1
  - 这里相当于求数组的 k 分位数，类比求中位数
- 算法
  - 选取S中一个元素作为枢纽元v，将集合S-{v}分割成S1和S2，就像快速排序那样
    - 如果k <= |S1|，那么第k个最小元素必然在S1中。在这种情况下，返回QuickSelect(S1, k)
    - 如果k = 1 + |S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它
    - 否则，这第k个最小元素就在S2中，即S2中的第（k - |S1| - 1）个最小元素，我们递归调用并返回QuickSelect(S2, k - |S1| - 1)
- 注意点
  - 枢纽元的选择有两种方法：一个是首元，一个是随机选择
  - 选择枢纽元之后还要对序列进行调整，之后才能计数，因此复杂度怎么出来的？
- 复杂度
  - 时间：平均 O(n)，最坏 O(n^2)，使用数学归纳法可证明
    - 假设 pivot 都选择在中间位置，且将 pivot 与 n 个数都进行了比较和调整：T(n) = cn + T(n/2)
    - 展开相消得到：T(n) = c(n + n/2 + n/4 + n/8 + ... + 2 + 1) = 2n = O(n)
  - 空间：inplace 方法

#### SELECT 算法：最坏情况下也为 O(n)

- 《算法导论》第9章第9.3节

## 04 问题总结

### Quick Select

- 背景

  - Quick select算法通常用来在未排序的数组中寻找第k小/第k大的元素。其方法类似于Quick sort。
  - Quick select和Quick sort都是由Tony Hoare发明的，因此Quick select算法也被称为是Hoare's selection algorithm。
  - Quick select算法因其高效和良好的average case时间复杂度而被广为应用。Quick select的average case时间复杂度为O(n)，然而其worst case时间复杂度为O(n^2)

- 算法

  - 总体而言，Quick select采用和Quick sort类似的步骤：

    - 选择：首先选定一个pivot，
    - 调整：然后根据每个数字与该pivot的大小关系将整个数组分为两部分
    - 减治：那么与Quick sort不同的是，Quick select只考虑所寻找的目标所在的那一部分子数组，而非像Quick sort一样分别再对两边进行分割

    > 正是因为如此，Quick select将平均时间复杂度从O(nlogn)降到了O(n)

#### 拓展

1、有两个序列A和B,A=(a1,a2,...,ak),B=(b1,b2,...,bk)，A和B都按升序排列。对于1<=i,j<=k，求k个最小的（ai+bj）。要求算法尽量高效。

- 算法 - 最小堆法（类似于 BFS 中队列的用法）
  - 创建容量为 k 的最小堆
  - a1 + b1 肯定是最小的，将其入堆
  - 将堆顶元素出堆，加入解集，将堆顶元素的邻居入堆
    - 假如此时堆顶元素为ai+bi,则需要像最小堆中压入a(i+1)+bj的和与ai+b(j+1)的和
    - 要保证下标不越界，如果下标越界了则忽略
    - 要保证已经压入过堆中的组合（即使已经从堆中被取出了的）不再被压入堆中
  - 重复上一步过程直到解集中含有 k 个元素
- 复杂度
  - 时间：O(klogk)，堆深度决定
  - 空间：O(k)

2、谷歌面试题：输入是两个整数数组，他们任意两个数的和又可以组成一个数组，求这个和中前k个数怎么做？

分析：排序

```
 “假设两个整数数组为A和B，各有N个元素，任意两个数的和组成的数组C有N^2个元素。
   那么可以把这些和看成N个有序数列：
          A[1]+B[1] <= A[1]+B[2] <= A[1]+B[3] <=…
          A[2]+B[1] <= A[2]+B[2] <= A[2]+B[3] <=…
          …
         A[N]+B[1] <= A[N]+B[2] <= A[N]+B[3] <=…
    问题转变成，在这N^2个有序数列里，找到前k小的元素”
```

- 算法
  - 首先缩减问题规模，利用本文的算法在 A，B 序列中各选择 k 个最小的元素，并对其排序
  - 在规模为 k 的序列中进行比较操作即可，复杂度 O(k^2)，此时可以使用矩阵 M 来表示这个问题
    - 设解集合为 ANS，我们可以用堆结构来表示
    - 在矩阵中，M00 是最小值，将其加入解集
    - 之后比较 M01 和 M10，选择最小的加入解集
    - 这里的过程同上一题
  - 若 k^2 规模小，使用上面的 topK 算法即可
- 改进，如果改为 N 个数组，则两两归并即可

3、给定一个数列a1,a2,a3,...,an和m个三元组表示的查询，对于每个查询(i，j，k)，输出ai，ai+1，...，aj的升序排列中第k个数。

> https://massivealgorithms.blogspot.com/2015/11/leetcode9-k.html