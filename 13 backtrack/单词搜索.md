# 单词搜索
> Author ID.9276 

**问题关键词：**

- 回溯

## 01 题目

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例:**

```
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true.
给定 word = "SEE", 返回 true.
给定 word = "ABCB", 返回 false.
```

## 02 输入分析



## 03 解题思路

### 3.1 基础思路

注意在入口处需要遍历所有的 dict 

注意 dfs 中减枝的讨论

### 3.2 算法优化



## 04 核心代码

```c++
class Solution {
public:
    
    bool existed = false;
    vector<vector<bool>> visited;
    
    bool exist(vector<vector<char>>& board, string word) {
        
        visited = vector<vector<bool>> (board.size(), vector<bool>(board[0].size(), false));
        
        if(word.empty()) return false;
        
        // find the first char in the dict
        for(int i = 0; i < board.size(); i++) {
            for(int j = 0; j < board[0].size(); j++) {
                dfs(word, 0, board, i, j);
                if(existed) return true;
            }
        }
            
        return false;
    }
    
    void dfs(string& word, int index, vector<vector<char>>& board, int i, int j) {
        
        // when find the result, cut the rest case.
        if(existed) return;
        
        // match the word
        if(index == word.length()) {
            existed = true;
            return;
        }
        
        // over the bound
        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size()) return;
        
        if(visited[i][j] == 0 && board[i][j] == word[index]) {
            visited[i][j] = true;
            index += 1;
            dfs(word, index, board, i, j+1);
            dfs(word, index, board, i, j-1);
            dfs(word, index, board, i+1, j);
            dfs(word, index, board, i-1, j);
            visited[i][j] = false;
        }
    }
};
```



## 05 算法效率分析



## 06 问题总结

