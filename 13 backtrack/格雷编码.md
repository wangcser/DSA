# 格雷编码
**问题关键词：**

- 回溯
- 数学

## 01 题目

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 *n*，打印其格雷编码序列。格雷编码序列必须以 0 开头。

**示例 1:**

```
输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2

对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。

00 - 0
10 - 2
11 - 3
01 - 1
```

**示例 2:**

```
输入: 0
输出: [0]
解释: 我们定义格雷编码序列必须以 0 开头。
     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
     因此，当 n = 0 时，其格雷编码序列为 [0]。
```

## 02 分析



## 03 题解

### 基础：回溯

- 模拟题，需要搞清楚格雷码的生成过程
  - 设我们的求解函数能够返回 n 位的格雷码，共 2 << n 个
  - 对于 n 位的情况，我们由 n - 1 位的情况可以求出
    - 将 n - 1 的结果作为 n 位的前 2 << n - 1 个编码加入 n 的解集中
    - 将 n - 1 的 2 << n - 1 个结果倒序加上 最高位的 1 代表的 2 的 n - 1 次幂，插入上一步的结果中
  - 对于边界条件：当 n = 0 时返回 0 即可



```c++
class Solution {
public:
    vector<int> grayCode(int n) {
        
        if(n == 0) return {0};
        
        vector<int> ans = grayCode(n - 1);
        
        for(int i = (1 << (n - 1)) - 1; i >= 0; i--)
            ans.push_back(ans[i] + (1 << (n - 1)));
        
        return ans;
    }
};
```



#### 数学

- 利用格雷码的在二进制表示下的异或计算规律

```java
        /**
        关键是搞清楚格雷编码的生成过程, G(i) = i ^ (i/2);
        如 n = 3: 
        G(0) = 000, 
        G(1) = 1 ^ 0 = 001 ^ 000 = 001
        G(2) = 2 ^ 1 = 010 ^ 001 = 011 
        G(3) = 3 ^ 1 = 011 ^ 001 = 010
        G(4) = 4 ^ 2 = 100 ^ 010 = 110
        G(5) = 5 ^ 2 = 101 ^ 010 = 111
        G(6) = 6 ^ 3 = 110 ^ 011 = 101
        G(7) = 7 ^ 3 = 111 ^ 011 = 100
        **/
```

```c++
class Solution {
public:
    vector<int> grayCode(int n) {
        
        vector<int> ans;
        
        for(int i = 0; i < 1 << n; i++)
            ans.push_back(i ^ (i >> 1));
        
        return ans;
    }
};
```

## 04 总结

