# 寻找重复的子树
> Author ID.9276 

**问题关键词：**

- 

## 01 题目

给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意**一棵**的根结点即可。

两棵树重复是指它们具有相同的结构以及相同的结点值。

**示例 1：**

```
        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4
```

下面是两个重复的子树：

```
      2
     /
    4
```

和

```
    4
```

因此，你需要以列表的形式返回上述重复子树的根结点。

## 02 输入分析



## 03 解题思路

### 3.1 基础思路

- 树的子树可以在其遍历过程中发现，因此先序遍历树，将每一个遍历路径存储为一个 string 的形式
  - 每一个包含 & 的路径代表一棵子树
- 将所有的 string 加入 hash map 进行统计和查重
  - 发现重复后将当前节点加入解集



这个题展示了搜索过程中统计和去重的思路

### 3.2 算法优化



## 04 核心代码

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        
        vector<TreeNode*> ans;
        unordered_map<string, int> m;
        
        if(root == NULL) return ans;
        
        preorder(root, ans, m);
        
        return ans;
    }
    
    string preorder(TreeNode* node, vector<TreeNode*>& ans, 
               unordered_map<string, int>& m) {
        
        if(node == NULL) return "&";
        
        string route = to_string(node->val) + "," + preorder(node->left, ans, m)+"," + preorder(node->right, ans, m);
        
        if(m[route] == 1) ans.push_back(node);
        
        m[route]++;
        
        return route;
    }
};
```



## 05 算法效率分析



## 06 问题总结

