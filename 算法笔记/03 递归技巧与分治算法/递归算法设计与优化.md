# 递归算法设计与优化

## 什么问题能够使用递归算法求解？

如果问题能够分解为子问题求解，那么一般能用递归设计思路设计算法求解。

## 如何设计一个递归算法？

分析问题，寻找递归算法的三大要素：

- 函数的功能
- 递归结束条件
- 递推关系式

### 1. 确定函数的功能

首先根据问题的求解目标定义函数的功能，一般都直接定义为问题的最终解形式

### 2. 确定递归结束条件

然后分解问题，找到问题可求解的最小子问题，以边界检查的形式定义在函数的开头

- 递归基是问题求解的基础，需要严格分析，防止出现越界和未定义的情况

### 3. 找出递推关系式

最后根据问题的分解过程，按照分治或者减治思路构造问题的递推关系式

- 对于简单的问题，直接返回关系式即可（斐波那契数，爬楼梯）
- 对于复杂的情况，根据函数的返回和输入确定中间操作（反转链表）

## 如何优化递归算法？

### 1. 考虑子问题是否有 overlapping？

如果子问题中有重复计算，我们可以缓存这些中间状态，每当需要重复计算时直接从缓存中取出即可

> 例如用 hashMap 来进行保存，当然用一个数组也是可以的，这个时候就像我们上面说的巧用数组下标了。可以当arr[n] = 0时，表示n还没计算过，当arr[n] != 0时，表示f(n)已经计算过，这时就可以把计算过的值直接返回回去

```
// 我们实现假定 arr 数组已经初始化好的了。
int f(int n){
    if(n <= 1){
        return n;
    }
    //先判断有没计算过
    if(arr[n] != -1){
        //计算过，直接返回
        return arr[n];
    }else{
        // 没有计算过，递归计算,并且把结果保存到 arr数组里
        arr[n] = f(n-1) + f(n-1);
        reutrn arr[n];
    }
}
```



### 2. 考虑改进为迭代求解？

递归算法一般来源于分治思想，问题求解采用自上而下的思路，我们可以自底向上地重构算法，充分利用缓存的结果构造问题的解–迭代

- 注意这里的缓存和上面方法的区别

```
public int f(int n) {
       if(n <= 2)
           return n;
       int f1 = 1;
       int f2 = 2;
       int sum = 0;

       for (int i = 3; i <= n; i++) {
           sum = f1 + f2;
           f1 = f2;
           f2 = sum;
       }
       return sum;
}
```



## reference

<https://mp.weixin.qq.com/s/mJ_jZZoak7uhItNgnfmZvQ>