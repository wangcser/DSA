# 乘积最大子序列
**问题关键词：**

- 二维 DP

## 01 题目

给定一个整数数组 `nums` ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

**示例 1:**

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

## 02 分析

- 输入一维整数序列
- 如果输入序列为空，应该返回 0
- 输入序列只有一个元素，不需要比较，返回该元素
- 对于当前元素 i：
  - 如果 i 为正数，则 i 与之前累积的**最大积**组合得到当前解
  - 如果 i 为负数，则 i 与之前累积的**最小积**组合得到当前解

## 03 题解

### 基础：考虑符号的 2 维 DP

- 最优解：设 opt(i, 0) 为以 i 元素结尾序列的**最小积**，设 opt(i, 1) 为以 i 元素结尾序列的**最大积**
- 基础情况：对于 i = 0 时，二者为 0
- 递推关系式：考虑负元素会改变之前积累的状态，详见代码

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        
        if(nums.empty()) return 0;
        if(nums.size() < 2) return nums[0];
        
        
        int opt[nums.size()][2] = {0};
        
        // init
        int ans = nums[0];
        opt[0][0] = nums[0];
        opt[1][0] = nums[0];
        
        for(int i = 1; i < nums.size(); i++) {
            opt[i][0] = min(min(opt[i-1][0] * nums[i], opt[i-1][1] * nums[i]), nums[i]);
            opt[i][1] = max(max(opt[i-1][0] * nums[i], opt[i-1][1] * nums[i]), nums[i]);
            ans = max(ans, opt[i][1]);
        }
        
        return ans;
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(2n)

## 04 总结

这里状态转移需要记录过去的两个状态