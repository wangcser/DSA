# 算法(五):图解贝尔曼-福特算法

## 算法简介

**贝尔曼-福特算法(Bellman–Ford algorithm )用于计算出起点到各个节点的最短距离，支持存在负权重的情况**

- 它的原理是对图进行最多V-1次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达O(VE)。但算法可以进行若干种优化，提高了效率。
- Bellman Ford算法每次对所有的边进行松弛，每次松弛都会得到一条最短路径，所以总共需要要做的松弛操作是V - 1次。在完成这么多次松弛后如果还是可以松弛的话，那么就意味着，其中包含负环。
- 相比[狄克斯特拉算法(Dijkstra algorithm)](https://juejin.im/post/5b7000ab6fb9a009bd03cb79),其最大优点便是Bellman–Ford支持存在负权重的情况，并且代码实现相对简单。缺点便是时间复杂度较高，达到O(V*E)，V代表顶点数，E代表边数。

可用于解决以下问题：

- 从A出发是否存在到达各个节点的路径(有计算出值当然就可以到达)；
- 从A出发到达各个节点最短路径(时间最少、或者路径最少等)
- 图中是否存在负环路（权重之和为负数）

其思路为：

1. 初始化时将起点s到各个顶点v的距离dist(s->v)赋值为∞，dist(s->s)赋值为0

2. 后续进行最多n-1次遍历操作(n为顶点个数,上标的v输入法打不出来...),对所有的边进行松弛操作,假设:

   所谓的松弛，以边ab为例，若dist(a)代表起点s到达a点所需要花费的总数， dist(b)代表起点s到达b点所需要花费的总数,weight(ab)代表边ab的权重， 若存在:

   (dist(a) +weight(ab)) < dist(b)

   则说明存在到b的更短的路径,s->...->a->b,更新b点的总花费为(dist(a) +weight(ab))，父节点为a

3. 遍历都结束后，若再进行一次遍历，还能得到s到某些节点更短的路径的话，则说明存在负环路

思路上与狄克斯特拉算法(Dijkstra algorithm)最大的不同是每次都是从源点s重新出发进行"松弛"更新操作，而Dijkstra则是从源点出发向外扩逐个处理相邻的节点，不会去重复处理节点，这边也可以看出Dijkstra效率相对更高点。

## 案例

### 案例一

先举个网上常见的例子介绍其实现的思路:

如下图按Bellman–Ford算法思路获取起点A到终点的最短路径



![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="412" height="285"></svg>)



由上介绍可知，由于该图顶点总数n=5个顶点，所以需要进行5-1 = 4 次的遍历更新操作，每次操作若能发现更短的路径则更新对应节点的值

1.首先建立边对象信息,需要按从源点A出发，由近到远的顺序，不然没从源点开始的话dist(s)==∞无穷大会增加后续计算的麻烦:

```
AB:-1
AC:4
BC:3
BE:2
BD:2
ED:-3
DC:5
DB:1
复制代码
```

1.首先列出起点A到各个节点耗费的时间:

| 父节点 | 节点 | 初始化 |
| ------ | ---- | ------ |
| A      | A    | 0      |
| ..     | B    | ∞      |
| ..     | C    | ∞      |
| ..     | D    | ∞      |
| ..     | E    | ∞      |



2.进行第一次对所有边进行的松弛操作:

2.1统计经过1条边所能到达的节点的值AB,AC：

```
AB:-1
AC:4
复制代码
```

| 父节点 | 节点 | 耗费   |
| ------ | ---- | ------ |
| A      | A    | 0      |
| A      | B    | **-1** |
| A      | C    | **4**  |
| ..     | D    | ∞      |
| ..     | E    | ∞      |



2.2统计经过2条边所能到达的节点的值BC,BD,BE：

```
BC:3
BE:2
BD:2
复制代码
```

| 父节点 | 节点 | 耗费  |
| ------ | ---- | ----- |
| A      | A    | 0     |
| A      | B    | -1    |
| B      | C    | **2** |
| B      | D    | **1** |
| B      | E    | **1** |



以节点C为例,因为满足: dist(B) + weight(BC) > dist(C),即 -1 + 3 >4，所以C更新为2

2.3统计经过3条边所能到达的节点的值ED,DC：

```
ED:-3
DC:5
DB:1
复制代码
```

| 父节点 | 节点 | 耗费   |
| ------ | ---- | ------ |
| A      | A    | 0      |
| A      | B    | -1     |
| B      | C    | 2      |
| E      | D    | **-2** |
| B      | E    | 1      |



3.尝试再进行第2次遍历，对所有边进行松弛操作，发现没有节点需要进行更新，此时便可以提前结束遍历，优化效率

| 父节点 | 节点 | 耗费 |
| ------ | ---- | ---- |
| A      | A    | 0    |
| A      | B    | -1   |
| B      | C    | 2    |
| E      | D    | -2   |
| B      | E    | 1    |



4.由上表可知，此时便求出了源点A到各个节点的最短路径与线路

### 案例二

如下图，求出A到各节点的最短路径



![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="563" height="309"></svg>)



1.该图共有节点7个，最多需要进行7-1=6次的对所有边的松弛操作

2.首先创建边对象:

```
AB:6
AC:5
AD:5
CB:-2
DC:-2
BE:-1
CE:1
DF:-1
EG:3
FG:3
复制代码
```

3.进行第一次遍历松弛操作，可以得到:

| 父节点 | 节点 | 耗费 |
| ------ | ---- | ---- |
| A      | A    | 0    |
| C      | B    | 3    |
| D      | C    | 3    |
| A      | D    | 5    |
| B      | E    | 2    |
| D      | F    | 4    |
| E      | G    | 5    |



4.进行第二次遍历松弛操作，得到:

| 父节点 | 节点 | 耗费 |
| ------ | ---- | ---- |
| A      | A    | 0    |
| C      | B    | 1    |
| D      | C    | 3    |
| A      | D    | 5    |
| B      | E    | 0    |
| D      | F    | 4    |
| E      | G    | 3    |



5.进行第三次遍历松弛操作，结果并没有再次更新:

| 父节点 | 节点 | 耗费 |
| ------ | ---- | ---- |
| A      | A    | 0    |
| C      | B    | 1    |
| D      | C    | 3    |
| A      | D    | 5    |
| B      | E    | 0    |
| D      | F    | 4    |
| E      | G    | 3    |



6.此时上表边上A到各个节点的最短路径，可以通过倒序的方式得出路线

8.这边假设同级边对象(指的是从A出发，经过相同的边数可以到达的，比如DC,CB,BE,DF,CE经过2条边就可以到达)排序位置进行调整,并不会影响结果的正确性，但是会影响所需要的遍历的次数(不同级别):

比如上述,AB:6 ,AC:5,AD:5,CB:-2,DC:-2,BE:-1,CE:1,DF:-1,EG:3,FG:3 代码需要遍历3次才可以确认结果(最后一次用于确认结果不再更新)；

AB:6，AC:5，AD:5，DC:-2，CB:-2，BE:-1，CE:1，DF:-1，EG:3，FG:3 代码需要遍历2次就可以确认结果；

AB:6，AC:5，AD:5，BE:-1，CE:1，DF:-1，DC:-2，CB:-2，EG:3，FG:3 代码需要遍历4次就可以确认结果；

有时候图的关系是用户输入的，对于顺序并不好强制一定是最佳的

## 局限性

### 案例三,存在负环路的情况



![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="412" height="285"></svg>)



- 对案例一的图进行修改B->D为-2.使得B<->D这形成了负环路，所谓的负环路指的是环路权重之和为负数，比如上图 1 + (-2) = -1 < 0即为负环路。
- 因为负环路可以无限执行循环步骤，只要你想，可以在 B->D->B->D...这边无限循环，所以B、D的取值可以无限小， 然后当B、D取值无限小后再从B、D节点出发到达其他各个节点，都会导致其它节点的取值同样接近无限小，所以对于负环路的情况，Bellman–Ford只能判断出图存在负环路，而没有求出各个节点最短路径的意义
- Bellman–Ford求出的各个节点的最短路径后，可以再进行一次遍历，就可以判断出是否存在负环路。

例如,同案例一，对该图执行4次遍历后得到结果:

| 父节点 | 节点 | 耗费 | 执行线路      |
| ------ | ---- | ---- | ------------- |
| A      | A    | 0    |               |
| A      | B    | -2   | A->B->D->B    |
| B      | C    | 1    | A->B->D->B->C |
| E      | D    | -4   | A->B->D-B->D  |
| B      | E    | 0    | A->B->D->B->E |



此时结束后，所得到的结果并非是正确的最短路径，比如再进行一次遍历，更新从源点A出发，经过5条边所能到达的节点的值

| 父节点 | 节点 | 耗费   | 执行线路         |
| ------ | ---- | ------ | ---------------- |
| A      | A    | 0      |                  |
| A      | B    | **-3** | A->B->D->B->D->B |
| B      | C    | 1      | A->B->D->B->C    |
| E      | D    | -4     | A->B->D-B->D     |
| B      | E    | 0      | A->B->D->B->E    |



**发现此时存在可以更新的节点B，则证明图中存在了负环路。**

**当没限制次数时，则无法得出各个节点的最短路径，若人为限制了遍历次数，则可以找出源点到各个节点的最短路径**

## 小结

1.广度优先算法BFS主要适用于无权重向图重搜索出源点到终点的步骤最少的路径，当方向图存在权重时，不再适用

2.狄克斯特拉算法Dijkstra主要用于有权重的方向图中搜索出最短路径，但不适合于有负权重的情况.对于环图，个人感觉和BFS一样，标志好已处理的节点避免进入死循环，可以支持

3.贝尔曼-福特算法Bellman–Ford主要用于存在负权重的方向图中(没有负权重也可以用，但是效率比Dijkstra低很多)，搜索出源点到各个节点的最短路径

4.Bellman–Ford可以判断出图是否存在负环路，但存在负环路的情况下不支持计算出各个节点的最短路径。只需要在结束(节点数目-1)次遍历后，再执行一次遍历，若还可以更新数据则说明存在负环路

5.当人为限制了遍历次数后，对于负环路也可以计算出，但似乎没啥实际意义

## 算法

- 针对每个点，都去判断每个边能否改进其代价