# 乘积最大子序列
> Author ID.9276 

**问题关键词：**

- 二维 DP

## 01 题目

给定一个整数数组 `nums` ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

**示例 1:**

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

## 02 输入分析

- 输入一维整数序列
- 如果输入序列为空，应该返回 0
- 输入序列只有一个元素，不需要比较，返回该元素
- 对于当前元素 i：
  - 如果 i 为正数，则 i 与之前累积的最大积组合得到当前解
  - 如果 i 为负数，则 i 与之前累积的最小积组合得到当前解

## 03 解题思路

### 3.1 基础思路

- 最优解：设 opt(i, 0) 为以 i 元素结尾序列的最小积，设 opt(i, 1) 为以 i 元素结尾序列的最大积
- 基础情况：对于 i = 0 时，二者为 0
- 递推关系式：考虑负元素会改变之前积累的状态，详见代码

### 3.2 算法优化



## 04 核心代码

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        
        if(nums.empty()) return 0;
        if(nums.size() < 2) return nums[0];
        
        
        int opt[nums.size()][2] = {0};
        
        // init
        int ans = nums[0];
        opt[0][0] = nums[0];
        opt[1][0] = nums[0];
        
        for(int i = 1; i < nums.size(); i++) {
            opt[i][0] = min(min(opt[i-1][0] * nums[i], opt[i-1][1] * nums[i]), nums[i]);
            opt[i][1] = max(max(opt[i-1][0] * nums[i], opt[i-1][1] * nums[i]), nums[i]);
            ans = max(ans, opt[i][1]);
        }
        
        return ans;
    }
};
```

## 05 算法效率分析

- 时间复杂度：O(n)
- 空间复杂度：O(2n)

## 06 问题总结

这里状态转移需要记录过去的两个状态