# k次取反后最大化的数组和
> Author ID.9276

## 01 题目

给定一个整数数组 A，我们**只能**用以下方法修改该数组：我们选择某个个索引 `i` 并将 `A[i]` 替换为 `-A[i]`，然后总共重复这个过程 `K` 次。（我们可以多次选择同一个索引 `i`。）

以这种方式修改数组后，返回数组可能的最大和。

 

**示例 1：**

```
输入：A = [4,2,3], K = 1
输出：5
解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。
```

**示例 2：**

```
输入：A = [3,-1,0,2], K = 3
输出：6
解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。
```

**示例 3：**

```
输入：A = [2,-3,-1,5,-4], K = 2
输出：13
解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。
```

 

**提示：**

1. `1 <= A.length <= 10000`
2. `1 <= K <= 10000`
3. `-100 <= A[i] <= 100`

## 02 分析

策略：尽量扩大数组中正数的数量，因此要比较 k 和负数数量之间的关系

由于最终结果与位置无关，因此可以先将数组排序

- 如果没有负数
  - k为偶数，则全为正数
  - k为奇数，选择最小正数取反（第一个元素）
- 含有负数，设其数量为 m
  - k - m > 0，先将序列转换为正数
    - 差为奇数，回到上面奇数的情况
    - 差为偶数，回到上面偶数的情况
  - k < m，说明翻转次数不够，将前 k 个元素翻转

上面的思路是可行的，但是存在一个隐含条件，每次翻转之后必须重新排序！！！



因此不如用下面代码的思路，其实就是上面思路的简化，注意第二次排序：

- 尽量翻转负数
- 如果还有剩余能力，就翻转最小的正数

## 03 题解

### 3.1 C++

```c++
//version 1.0 0.0%
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& A, int K) {
        
        sort(A.begin(), A.end());
        
        for(int i = 0; i < A.size(); i++){
            if(A[i] < 0 && K > 0) {
                A[i] = -A[i];
                K--;
            }
        }
        
        sort(A.begin(), A.end());
        
        if(K % 2 != 0) A[0] = -A[0];
        
        int sum = 0;
        for(auto n : A) {
            sum += n;
        }
        
        return sum;  
    }
};
```

### 3.2 Python 3

```python
# version 1.0 0.0%

```

### 3.3 Go

```Go
//version 1.0 0.0%

```



## 04 总结

