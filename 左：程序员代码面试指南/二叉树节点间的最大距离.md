# 二叉树节点间的最大距离
> Author ID.9276 

**问题关键词：**

- 

## 01 题目

## 题目描述

从二叉树的节点 A 出发，可以向上或者向下走，但沿途的节点只能经过一次，当到达节点 B 时，路径上的节点数叫作 A 到 B 的距离。

现在给出一棵二叉树，求整棵树上每对节点之间的最大距离。

## 输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)最后一行为节点 o1 和 o2。
```

## 输出描述:

```
输出一个整数表示答案。
```

示例1

## 输入

[复制](javascript:void(0);)

```
7 1
1 2 3
2 4 5
4 0 0
5 0 0
3 6 7
6 0 0
7 0 0
```

## 输出

[复制](javascript:void(0);)

```
5
```

## 备注:

```
1 \leq n \leq 5000001≤n≤5000001 \leq fa,lch,rch,root \leq n1≤fa,lch,rch,root≤n
```

## 02 分析



## 03 题解

### 基础：树型 DP

```c++
#include <iostream>
#include <vector>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <climits>

using namespace std;


class TreeNode {
public:
    int val;
    TreeNode *left;
    TreeNode *right;

    TreeNode(int num) : val(num), left(nullptr), right(nullptr) {}
};

TreeNode *readTree() {
    // read tree
    int n, r;
    map<int, TreeNode *> nodeMap;

    scanf("%d%d", &n, &r);
    //  create node and store it into dict
    for (int i = 1; i <= n; ++i) {
        TreeNode *newNode = new TreeNode(i);
        nodeMap[i] = newNode;
    }

    TreeNode *root = nodeMap[r];

    // build tree:use dict to link node
    int parent, lchild, rchild;
    for (int i = 0; i < n; ++i) {
        scanf("%d%d%d", &parent, &lchild, &rchild); // ctrl + z is EOF
        if (lchild != 0) {
            nodeMap[parent]->left = nodeMap[lchild];
        }
        if (rchild != 0) {
            nodeMap[parent]->right = nodeMap[rchild];
        }
    }

    return root;
}

class ReturnType {
public:
    int maxdis;
    int height;

    ReturnType(int dis, int h) : maxdis(dis), height(h) {}
};

class Solver {
public:
    ReturnType *solve(TreeNode *root) {
        if (!root)
            return new ReturnType(0, 0);

        ReturnType *left = solve(root->left);
        ReturnType *right = solve(root->right);

        int height = max(left->height, right->height) + 1;
        int maxdis = max(left->height + right->height + 1,
                         max(left->maxdis, right->maxdis));

        return new ReturnType(maxdis, height);
    }

private:

};

int main() {
    vector<TreeNode *> nodes(3);
    TreeNode *root = readTree();

    // solver
    Solver solver;
    ReturnType *ret = solver.solve(root);
    cout << ret->maxdis;

    return 0;
}
```



### 优化：



## 04 总结

