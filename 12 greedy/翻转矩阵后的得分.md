# 翻转矩阵后的得分
> Author ID.9276 

**问题关键词：**

- 贪心

## 01 题目



## 02 输入分析



## 03 解题思路

### 3.1 基础思路

```python3
思路：
可以这样看，n*m的每个格子都具有一个权重，其中每一行权重都自左向右递减，
为使总和最大则尽可能使权重大的格子填“1”。最左边一列权重最大，所以总可以通过
行翻转使左边第一列全都置“1”，后面就不能再使用行翻转了，以免破环当前的结构，
所以考虑列翻转。对于除最左边第一列外的每一列，总可以通过列翻转使得该列“1”
的个数不小于“0”的个数。最后所有填“1”的格子的权重和即为答案。
```

### 3.2 算法优化



## 04 核心代码

```c++
class Solution {
public:
    int matrixScore(vector<vector<int>>& A) {
        
        if(A.size() == 0) return 0;
        
        int m = A.size();
        int n = A[0].size();
        int ans = 0;
        
        for(int i = 0; i < m; i++) {
            if(A[i][0] == 0)
                flipRow(A, i);
        }
        
        for(int j = 1; j < n; j++) {
            int one = 0;
            int zero = 0;
            for(int i = 0; i < m; i++) {
                if(A[i][j] == 1)
                    one++;
                else
                    zero++;
            }
            if(zero > one)
                flipCol(A, j);
        }
        
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(A[i][j] == 1)
                    ans += 1 << (n - 1 - j); 
            }
        }
        
        return ans;
    }
    
    void flipRow(vector<vector<int>>& A, int i) {
        
        for(int j = 0; j < A[0].size(); j++) {
            A[i][j] = 1 - A[i][j];
        }
    }
    
    void flipCol(vector<vector<int>>& A, int j) {
        
        for(int i = 0; i < A.size(); i++) {
            A[i][j] = 1 - A[i][j];
        }
    }
};
```



## 05 算法效率分析



## 06 问题总结

- 注意，这里使用了移位运算来计算幂，底数为 1 不是 2