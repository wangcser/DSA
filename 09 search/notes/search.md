# 查找算法

## 符号表

符号表是 <key, value> 的集合，有多种数据结构的实现，查找问题，就是对符号表中的 key 进行访问，查找其 value 的过程

高效的查找算法，依赖于：

- 数据结构
- 插入 out
- 查找 get

有序的符号表只能够按 key 排序的符号表，他能够提供更多的应用，此时引入了新的 API 支持：

- 最小 key
- 最大 key
- 排名
- 选择

算法需求：

- 构造庞大符号表的同时能够支持高效的插入/删除键值对，同时还要能够完成高效的查找操作

算法关键操作：

- 比较

## 无序符号表：无序链表 + 顺序查找

实现：

- DSA
  - 单向链表，数据区由两个字段构成：key, value
- get 
  - 遍历链表
- put
  - 遍历链表，存在则更新，否则在头部插入新的节点

性能：

- 未命中的查找和插入需要 N 次比较
- 随机命中需要 N/2 次比较
- 向空表插入 N 个不同的 key 需要 N^2/2 次比较

## 有序符号表：有序数组 + 二分查找

实现：

- DSA
  - 一对平行数组，一个存储 key， 一个存储 value
- rank
  - 基于二分查找算法，无论 key 存在与否，返回数组中小于给定 key 的键的数量（key 的 index）
- put
  - 由 rank 的返回值确定插入的位置，更新已有的值或是动态插入新的值
- get
  - 由 rank 的返回值确定查找的结果

性能：

- 二分查找有效减少了比较的次数，为 log N 级别
- 插入操作最坏情况下达到 N^2 级别（N个数，每次都要在数组的顺序头部插入 log N 次比较和 N 次移动）

总结：改进了比较操作

## 有序符号表：二叉查找树 BST

- 链表插入的灵活性
- 有序数组查找的高效性

实现：

- DSA
  - 一棵二叉树，每个节点存储可比较的 key 和 value
  - left->key <= root->key <= right->key
  - 节点内维护一个节点计数器，保存以该节点为 root 的子树中所有节点的数量（简化了很多操作）
- get
  - 子树为空（leaf），则未命中
  - root->key = key，命中
  - root->key > key，递归查找左子树
  - root->key < key，递归查找右子树
- put
  - 子树为空，则在当前位置插入新节点
  - root->key = key，更新 value
  - root->key > key，递归查找左子树，更新左链接
  - root->key < key，递归查找右子树，更新右链接
  - 更新节点计数器

性能：

- 取决于树的形状，树的形状取决于 key 插入的先后顺序
  - 最好情况，树完全平衡，树高 logN
  - 最坏情况，树退化为链表，树高 N
- 查找命中的平均比较次数为 lnN
- 插入操作和查找未命中的平均比较次数为 lnN

删除操作：

- delMin：删除最小键（仅含右子树）
  - 找到树中最左侧的节点，该节点处为最小键
  - 将指向该节点的链接更新为指向该节点的右子树（该节点没有左子树）
  - 向上更新父节点的链接和计数器
- del：删除任意节点（含有左右子树），Hibbard 后继删除法 
  - 找到待删除的节点，保存指向该节点的链接（用于更新其左右子树）
  - 使用该节点的后继节点替换被删除节点，这个节点会被函数返回（后继节点为在该节点的右子树中的最小键节点，找到后保留指向该节点的链接）
  - 后继节点的右子树 = 被删除节点更新后的右子树（删除了后继节点）
  - 后继节点的左子树 = 被删除节点的左子树
  - 向上更新父节点的链接和计数器

删除操作的性能：

- Hibbard 删除法没有考虑到树的对称性

总结：

- 在一棵二叉查找树中，所有操作的最坏情况都与树高成正比