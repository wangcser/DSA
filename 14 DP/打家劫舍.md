# 打家劫舍 

> Author：ID.9276

## 01 题目

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你**在不触动警报装置的情况下，**能够偷窃到的最高金额。

**示例 1:**

```
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2:**

```
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

## 02 分析

本题与最大子序和思路基本相同，区别在于子问题的定义

- 设子问题 opt(i) 为 A[0~i] 的最优解
- 去重：观察子问题，发现 opt(i) ，opt(i-1)，opt(i-2) 之间可以通过 A[i] 建立联系：
  - 若opt 包含i，则最优解就为 opt(i-2) + A[i] （不相邻）;
  - 若opt 不包含i，则最优解为 opt(i-1);
- 因此状态转移方程或者说递推关系式如下（迭代形式）：

$$
opt(i) = \max( opt(i-2) + A[i], opt(i-1))
$$

## 03 题解

### 3.1 C++

```c++
// version 1.0 55.17%
// DP-迭代

class Solution {
public:
    int rob(vector<int>& nums) {
        
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);
        
        int ans;
        vector<int> opt(nums.size());
        
        opt[0] = nums[0]; // 迭代的基础
        opt[1] = max(nums[0], nums[1]); 
        
        ans = opt[0]; // 记录最大值，不再回溯
        
        for(int i=2; i<nums.size(); i++){
            opt[i] = max(opt[i-1], opt[i-2] + nums[i]);
            if(opt[i] > ans) ans = opt[i];
        }
            
        return ans;
    }
};
```



### 3.2 Python 3

```python
# version 1.0 

```

### 3.3 Java

```java
// version 1.0

```



## 04 总结

