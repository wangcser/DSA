# 鸡蛋掉落
**问题关键词：**

- 二维 DP

## 01 题目

你将获得 `K` 个鸡蛋，并可以使用一栋从 `1` 到 `N`  共有 `N` 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 `F` ，满足 `0 <= F <= N` 任何从高于 `F` 的楼层落下的鸡蛋都会碎，从 `F` 楼层或比它低的楼层落下的鸡蛋都不会破。

每次*移动*，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 `X` 扔下（满足 `1 <= X <= N`）。

你的目标是**确切地**知道 `F` 的值是多少。

无论 `F` 的初始值如何，你确定 `F` 的值的最小移动次数是多少？

**示例 1：**

```
输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
```

**示例 2：**

```
输入：K = 2, N = 6
输出：3
```

**示例 3：**

```
输入：K = 3, N = 14
输出：4
```

**提示：**

1. `1 <= K <= 100`
2. `1 <= N <= 10000`

## 02 输入分析

- 问题的求解目标为，不管鸡蛋在哪个楼层会碎，对于给定的 N 层楼和 K 个鸡蛋，你能够判断出准确楼层所需要的最小测试次数是多少？
  - 举一个特殊的例子：对于只有一个鸡蛋的场合，考虑到从中间楼层扔可能无法完成测试任务，因此你必须从一楼开始逐层测试
- 或者说，**在最坏情况下，你需要移动的最少次数**是多少？

## 03 解题思路

从直觉上来看，这个问题似乎可以使用二分查找来建模，我们每次都选择楼层的中点进行测试，每次测试都将问题的规模缩小一半，下面考虑一个简单的情况，K=2，N=10，对于二分查找：

- 第一个鸡蛋从 5 楼扔下：
  - 碎了，下一个鸡蛋测试 1,2,3,4 楼，一共需要 5 步
  - 没碎，用这个鸡蛋测试 7 楼：
    - 碎了，测试 6 楼，一共需要 3 步
    - 没碎，用这个鸡蛋测试 9 楼：
      - 碎了，测试 8 楼，一共需要 4 步
      - 没碎，测试 10楼，一共需要 4 步
- 二分查找给出的最优解是 5 步（考虑最坏情况）

简单改进第一次操作就能得到问题的最优解 —— 4 步，过程如下：

- 第一个鸡蛋从 4 楼扔下：
  - 碎了，下一个鸡蛋测试 1,2,3 楼，一共需要 4 步
- 没碎，用这个鸡蛋测试 7 楼：
  - 碎了，测试 5，6 楼，一共需要 4 步
  - 没碎，用这个鸡蛋测试 9 楼：
    - 碎了，测试 8 楼，一共需要 4 步
    - 没碎，测试 10楼，一共需要 4 步

二分法虽然不是问题的最优解，但是可能是问题的一个近似解，同时我们可以得到下面的观察：

1. 最坏情况可能是一摔就碎的情况，因为这样不能有效地缩减问题的规模
2. 最优解序列不是简单序列，相反，我们可以通过最优解反推最优解序列

因此，这个问题应该用 DP 建模：

1. 分析动态规划问题的关键往往来自于 base case 的分析，因此要先找出问题的 Base case
2. 从基本情况出发，结合一般情况分析问题的递推关系式
3. 这个问题的难点在：
   1. 使用了两次最值判断
   2. 每个状态由多个过去状态决定，而不是一般 DP 问题的 2 个状态

### 3.1 基础思路

这是一个经典的**二维动态规划**问题，因此难点在于两个方面:

- 如何设计问题的最优解
- 如何分析问题的 DP 递推关系式

#### 思路 1：最优解为给定楼层数下确定 F 所需的最小操作数

第一步，定义最优解：假设 opt(K, N) 代表最多使用 K 个鸡蛋，需要判断的层数为 N 时问题对应的解，

第二步，分析基本情况：首先考虑问题的初始情况：

- 若鸡蛋数为 0，尝试 0 次即可：$opt(0, x) = 0$
- 若楼层数为 0，尝试 0 次即可：$opt(K, 0) = 0$
- 若鸡蛋数为 1，对于 k 层楼来说，最坏情况需要尝试 k 次（由于只有一个鸡蛋，为了完成目标，必须从 1 楼开始扔，最坏情况下 k 楼都没有碎）：$opt(1, x) = x$
- 若楼层数为 1，对于任意数量的鸡蛋，都只需要尝试 1 次即可：$opt(K, 1) = 1$

第三步，由一般情况求解递推关系式：对于任意楼层，我们将鸡蛋从 x 层扔下，会产生以下两种情况：

- 鸡蛋碎了，我们继续用剩下的 K - 1 个鸡蛋测试 x 以下的楼层，opt(K, N) = opt(K-1, x-1) + 1，这里的 1 表示从上一个状态到下一个状态需要一个操作数
- 鸡蛋没碎，我们继续用 K 个鸡蛋测试 x 以上的楼层，共有 N - x 个楼层需要测试，opt(K, N) = opt(K, N - x) + 1，这里 1 的意义同上

对于上面的情况，问题求解的是**最坏情况下最小**的鸡蛋移动次数，对于在特定楼层 x 进行的测试，最坏情况的意义就是选择操作数最多的情况，因此选择两种情况中的最大的值：
$$
opt(K, x)= \{\max(opt(K-1, x-1)+1, opt(K, N - x)+1)
$$

对于所有楼层来说，最小的移动次数的意义在于选择所有测试楼层中能够达到目标的最小值

综合上面的分析可以得到下面的递推公式（可以将公式中的 1 拿到最外侧）：
$$
opt(K, N)= \min_{1\lt x\lt N}\{\max(opt(K-1, x-1)+1, opt(K, N - x)+1)\}
$$
利用上面的公式可以直接得到 DP 解法

```c++
class Solution {
public:
    int superEggDrop(int K, int N) {
        
        // int optMatrix[K + 1][N + 1] = {0};
        vector<vector<int>> optMatrix(K + 1, vector<int>(N + 1, 0));
        
        for(int i = 0; i <= N; i++) {
            optMatrix[1][i] = i;
        }
        
        for(int i = 2; i <= K; i++) {
            for(int j = 1; j <= N; j++) {
                int opt = INT_MAX;
                
                for(int x = 1; x <= j; x++) {
                    opt = min(opt, (1 + max(optMatrix[i][j-x], optMatrix[i-1][x-1])));
                }
                optMatrix[i][j] = opt;
            }
        }
        
        return optMatrix[K][N];
    }
};
```

注：这个思路得到的代码正确性上没有发现问题，但是存在超时问题（求最值引入的第三个循环）

#### 思路 2：最优解为给定操作数下能测定的最大楼层数

定义最优解：设 opt(k, m) 表示使用 k 个鸡蛋在 m 个步骤内能确定的最大层数，问题转化为当 k <= K 时，找到一个最小的 m，使得 opt(k, m) <= N

分析基本情况：

- 没有鸡蛋则无法进行测试，有 opt(0, m) = 0
- 1 个鸡蛋在执行 m 步的条件下（说明鸡蛋没碎）最多测试 m 层：opt(1, m) = m

分析一般情况：

- 假设 k 个鸡蛋进行到第 m 步时，在 N 层楼的第 x 层扔鸡蛋，通过这个鸡蛋结果我们可以确定：
  - 如果鸡蛋没碎，则我们会在 (x, N] 测试，最多测试 N-x + opt(k-1, m-1)
  - 如果鸡蛋碎了，则我们会在 [0, x) 测试，最多确定 x + opt(k, m-1)
- 因此我们通过扔这一次鸡蛋，我们最多能测出的楼层数量为下面内容的和：
  - 摔碎时确定的楼层数
  - 没摔碎确定的楼层数
  - 所在楼层的计数

$$
opt(k, m) = opt(k-1, m-1) + opt(k, m-1) + 1
$$

利用这个思路得到的算法如下：

```c++
class Solution {
public:
    int superEggDrop(int K, int N) {
        
        vector<vector<int>> opt(N + 1, vector<int>(K + 1, 0));
        
        int m = 0; // 0 step with 0 floors.
        
        // dp[m][K] is the max floors with K eggs and m steps.
        // when dp[m][K] == N, we get the min steps m.
        while (opt[m][K] < N) {
            m++;
            for (int k = 1; k <= K; ++k)
                opt[m][k] = opt[m - 1][k - 1] + opt[m - 1][k] + 1;
        }
        
        return m;
    }
};
```

## 04 算法理解

对于这个动态规划问题，我们可从它的解入手分析其实际意义。

对于 3 个鸡蛋， 10 层楼的问题，算法求得的解如下（直接输出 optMatrix 即可）：

```c++
[[ 0  0  0  0  0  0  0  0  0  0  0]
 [ 0  1  2  3  4  5  6  7  8  9 10]
 [ 0  1  2  2  3  3  3  4  4  4  4]
 [ 0  1  2  2  3  3  3  3  4  4  4]]
opt = 4
```

- 第一行：0 个鸡蛋对于任意层数不能进行测试
- 第二行，1 个鸡蛋对于任意层数，采用逐层测试的方法，测试所有层需要的最少的次数 = 层数
- 第一列：对于 0 层来说不需要进行测试
- 第二列：对于 1 层来说只需要 1 个鸡蛋进行 1 次测试即可完成测试
- 对于任意结果，我们以 opt(2, 2) 来说，它的解取决于：
  - 使用 2 个蛋测试 2 层：max(opt(2, 0), opt(1,1)) + 1
  - 使用 2 个蛋测试 1 层：max(opt(2, 1), opt(1,0)) + 1
- 因此，每一状态的解取决于：
  - 同一行之前的状态
  - 上一行之前的状态

对于这个解我们解释如下：

1. 第一个鸡蛋从 5 楼扔下：摔碎则下一个鸡蛋测试 1~4 楼，否则测试 6~10 楼
2. 第二个鸡蛋从 2 楼扔下：摔碎则下一个鸡蛋测试 1 楼，否则测试 3~4 楼
3. 第二个鸡蛋从 8 楼扔下：摔碎则下一个鸡蛋测试 7 楼，否则测试 9~10 楼
4. 第三个鸡蛋从 1 楼扔下，得到问题的一个解
5. 第三个鸡蛋从 7 楼扔下，得到问题的一个解
6. 第三个鸡蛋从 4 楼扔下，还需测试一次
7. 第三个鸡蛋从 10 楼扔下，还需测试一次

对于 K=2，N=50 的情形，采用另一种分析如下：

| 从哪一层扔鸡蛋 | 鸡蛋摔碎后的情形               | 次数   |
| :------------- | :----------------------------- | :----- |
| 10             | 1->2->3->4->5->6->7->8->9      | 9+1=10 |
| 19             | 11->12->13->14->15->16->17->18 | 8+2=10 |
| 27             | 20->21->22->23->24->25->26     | 7+3=10 |
| 34             | 28->29->30->31->32->33         | 6+4=10 |
| 40             | 35->36->37->38->39             | 5+5=10 |
| 45             | 41->42->43->44                 | 4+6=10 |
| 49             | 46->47->48                     | 3+7=10 |
| 50             |                                | 8      |

操作步骤如下：

- 对于 K 个鸡蛋，使用前 K - 1 个鸡蛋缩小问题的规模
  - 楼层序列由算法决定，不是简单序列
- 使用最后一个鸡蛋在最小区间上从下往上遍历即可

## 05 算法效率分析

对于两种思路，都使用了表格存储中间状态，因此空间复杂度为：O(KN)

时间复杂度上，对于思路一，三重循环引入的时间复杂度为 O(KNN)

对于思路二，原文提供的时间复杂度为 O(KlogN)

## 06 问题总结

时间关系暂时不对这个题目做深入的分析，从 github 的文章可以知道这个题目可以从指数时间复杂度算法开始优化，将来有空再来深入分析吧。



## Reference

- 这篇文章分析了问题的解空间：<https://www.cnblogs.com/yunlambert/p/10028865.html>
- <https://segmentfault.com/a/1190000015181763>
- 这篇文章对启发式算法总结很到位：<https://juejin.im/post/5b98785de51d450e71250aab>
  - 考虑二分法
  - 平方根法
  - 解方程法
- 这篇文章对算法优化分析的很到位：<https://github.com/Shellbye/Shellbye.github.io/issues/42>
- <https://www.zhihu.com/question/19690210>
- 这篇论文对问题做了全面的分析：[https://github.com/ericliu859/AcmPaper/tree/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%BC%98%E5%8C%96/2004%20-%20%E6%9C%B1%E6%99%A8%E5%85%89%EF%BC%9A%E3%80%8A%E4%BC%98%E5%8C%96%EF%BC%8C%E5%86%8D%E4%BC%98%E5%8C%96%EF%BC%81%E2%80%94%E2%80%94%E4%BB%8E%E3%80%8A%E9%B9%B0%E8%9B%8B%E3%80%8B%E4%B8%80%E9%A2%98%E6%B5%85%E6%9E%90%E5%AF%B9%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%E3%80%8B](https://github.com/ericliu859/AcmPaper/tree/master/动态规划/优化/2004 - 朱晨光：《优化，再优化！——从《鹰蛋》一题浅析对动态规划算法的优化》)