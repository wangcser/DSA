# 最长回文子串
> Author ID.9276 

**问题关键词：**

- DP

## 01 题目

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

**示例 1：**

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

**示例 2：**

```
输入: "cbbd"
输出: "bb"
```

## 02 输入分析



## 03 解题思路

### 3.1 基础思路

#### 思路 1：穷举搜索

#### 思路 2：中心扩展法

#### 思路 3：动态规划

这里有很多细节啊，注意边界条件

<https://www.jianshu.com/p/a7741619dd58>

`dp[i][j]`表示s[i..j]是否回文 是则为true，否则为false

- `s[i]=s[j]` 则 `dp[i][j]`取决于s[i+1..j-1]是否是回文串
- `s[i]!=s[j]` 则`dp[i][j]`=false

基本情况

- `dp[i][i]=true`
- `dp[i][i+1]=s[i]==s[i+1]`

##### 思路 4：Manacher 方法

### 3.2 算法优化



## 04 核心代码

中心扩展法

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        
        if(s.length() < 2) return s;
        
        string es;
        string es_ans;
        string ans;
        
        // warp the string to avoid even mid check case
        for(auto c : s) {
            es.push_back('#');
            es.push_back(c);
        }
        es.push_back('#');
        
        int maxLen = 0;
        int start = 0;
        for(int i = 0; i < es.length(); i++) {
            int subLen = subPalidrome(es, i);
            if(maxLen < subLen) {
                maxLen = subLen;
                start = i;
            }
        }
        
        cout<<start<<" "<<maxLen<<endl;
        
        es_ans = es.substr(start-maxLen, 2 * maxLen);
        
        cout<<es_ans;
        
        for(int i = 0; i < es_ans.length(); i++) {
            if(es_ans[i] != '#')
                ans.push_back(es_ans[i]);
        }
        
        return ans;
    }
    
    int subPalidrome(string& s, int i) {
        
        int len = 0;
        int k = 0;
        
        for( ; k <= i && k < (s.length() - i); k++) {
            
            if(s[i-k] == s[i+k])
                len++;
            else
                break;
        }
        
        return k-1;
    }
};
```

DP

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        
        if(s.length() < 2) return s;
        
        vector<vector<int>> opt(s.length(), vector<int>(s.length(), 0));
        int start = 0;
        int len = 1;
        
        for(int i = s.length() - 2; i >= 0; i--) {
            
            opt[i][i] = 1;
            
            for(int j = i + 1; j < s.length(); j++) {
                if(s[i] == s[j] && (j - i <= 2 || opt[i+1][j-1]))
                    opt[i][j] = 1;
                
                if(opt[i][j] && len < j - i + 1) {
                    start = i;
                    len = j - i + 1;
                    
                    cout<<start<<" "<<len<<endl;
                }
            }
        }
        // cout<<start<<" "<<len<<endl;
        
        return s.substr(start, len);
    }
};
```



## 05 算法效率分析



## 06 问题总结

对于 STL:: string 类型的总结：

- 区分 append 和 push_back 的输入对象
  - 前者是 string，双引号包围
  - 后者是 char，单引号包围