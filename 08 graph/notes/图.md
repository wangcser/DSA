# 图算法

## 图模型

- 使用大小为 V 的数组表示顶点，顶点从 0 编号到 V-1
- 使用符号表来建立定点到顶点 ID 的映射关系，这点一般是不需要的
- 用点对表示边

图的 API：

- 关键在于 adj 邻接方法的实现

```
class Graph {
	Graph(int V)
	Graph(In in)
	int V()
	int E()
	void addEdge(int v, int u)
	iterable<int> adj(int v)
	string toString()
}
```

图的输入表示：

共有 2 × E + 2 个输入，E + 2 行

- 第一行代表点数 V
- 第二行代表边数 E
- 之后有 E 行点对

```
13
13
0 5
4 3
...
```

图的数据结构表示：

- 邻接矩阵：
  - V×V 的布尔数组
  - 矩阵对于稀疏图和大图来说可能不现实
  - 无法表示平行边
- 边的数组
  - 定义一个 edge 类，使用两个 int 变量保存边
  - 对于 adj() 方法需要遍历整个边集
- 邻接表数组
  - 使用以顶点为索引的列表数组（顶点编号从 0 ～ V - 1），数组中每个元素是该顶点相邻接的顶点列表

### 无向图

#### 无向图的表示：邻接表

邻接表的数据结构：

- 邻接操作：每个顶点及其相邻的顶点用链表表示
- 遍历操作：使用数组保存顶点（头指针）

邻接表的特点：

- 每条边会出现两次
- 空间正比于 V + E
- 加边操作为常数时间
- 遍历顶点 V 的 adj-node 正比于 V 的度
- 支持平行边和自环
- 边的插入顺序决定了数组中点的输入顺序，也代表了遍历时点的顺序

邻接表结构的拓展：

- 支持点的添加与删除：将点数组改为符号表 ST，直接用点名进行检索
- 支持边的删除与查找：将链表替换为 set，此时 DSA 变为 邻接集
- 转化为符号图：增加两个数据结构来完成顶点名到顶点编号的映射
  - 符号表：string node_id ->int vertex_id
  - 反向索引： int vertex_id -> string node_id

图算法中常用的处理方法：

- search：连通性搜索，找到和输入的起点 s 连通的所有顶点
  - 使用 union-find 算法
- marked：联通点标记
- count：连通顶点的总数

#### 深度优先搜索 DFS

- DSA
  - 系统调用栈
- DFS
  - 访问当前节点并标记（最晚入栈的顶点）
  - 递归访问当前节点所有没有被标记的节点
    - 从当前节点的 adj 中选择一个进行访问
    - 当访问到标记过的节点时，利用系统栈回退
- 特点：
  - 算法遍历顺序和图的表示有关
  - 系统栈中存储了所有的分叉点

基于 DFS 求解的问题：

##### 寻找图中到起点 s 的所有路径

- DSA
  - 使用一个 uf 数组，记录路径信息
  - 注意：uf 是图中保存边结构的一种常用选择
- DFS
  - 每遍历一条边 v-w，就将这条边放入 uf 数组：uf[w] = v
  - 注意这里的路径顺序是颠倒的
  - uf 中生成的结果是以 s 为 root 的树
- pathTo
  - 遍历 uf 数组，使用辅助栈恢复路径上节点的顺序

##### 寻找图中的连通分量

- DSA
  - uf 数组，直接用当前分量的 root 标记每个顶点的归属
  - count 变量，既是连通分量计数器，也是 uf 数组标志

特点：

- 对于这类问题我们一般用并查集完成

##### 判断图中的是否有环

- 方法：
  - 对于 dfs ，要么深入，要么返回
  - 如果访问到已标记节点后都没有返回，说明入环了

##### 判断图是否是二分图

- DSA
  - uf 数组，保存每个点的颜色
- 方法：
  - 每次深入就覆盖边上两点的颜色
  - 遇到已经访问过的点就判断颜色是否相同，相同则不是二分图（不存在涂色方案）

#### 广度优先搜索 BFS

- DSA
  - 队列
- BFS
  - 取队列中的下一个顶点（最早入队的顶点），访问并标记
  - 将该顶点下未被标记的顶点加入队列

##### 单点最短路问题

- DSA
  - 使用 uf 维护路径信息（相当于层数）

### 有向图

#### 有向图的表示：邻接表

表示：

- 有向图中的边是单向的，表示一个有序对
- 由第一个点（头）指出，由第二个点（尾）指入
- 两点间边的关系存在 4 种组合

数据结构：

- 邻接表 - > 没有了对称性
  - 边链表只记录入节点
  - 每条边只出现一次

有向图的 API：

- adj：返回指出的所有节点
- reverse：返回图的反转，可以用于求指入的所有节点

##### 有向图的可达性

无向图中的连通性问题表示为有向图中的可达性问题，注意区别连通性和可达性

- DSA
  - 直接使用 DFS 即可
  - DFS 更适合有向图

应用：

- 内存中的垃圾回收
- 单点有向路径
- 单点最短有向路径（BFS）

#### 环与 DAG

##### 任务调度问题

问题：

- 给定一组任务，安排他们的执行顺序
- 任务具有不同的约束，最重要的一种为优先级限制
- 该问题可以建模为有向图模型

在有向图中，优先级限制下的调度问题等价于图中节点的拓扑排序

- 拓扑排序是该问题的一个解

##### 有向环检测

- DSA
  - 使用 cycle 栈记录系统栈中的路径
  - 将 uf 数组中的结果导出
- DFS
  - 对于每一个入栈的元素，将其 uf 数组中的路劲导入 cycle 栈中

##### 顶点的深度优先次序排序

- DSA
  - 在 DFS 算法中，将当前访问的参数顶点保存在一个数据结构中，遍历该结构就能得到一个顺序
- 保存的位置——遍历顺序
  - 前序，递归调用前入队
  - 后序，递归调用后入队
  - 逆后序，递归调用后入栈

#####　拓扑排序

定义：

- 给定一幅有向图，将所有顶点排序
- 所有有向边从排在前面的元素指向排在后面的元素
- 或者证明不存在这样的排序

性质：

- DAG 才存在拓扑排序
- 如果图中有有向环，则不存在拓扑排序

算法：

- DSA
  - 一幅 DAG 的拓扑排序就是所有顶点的逆后续排列（reversePost）

##### 优先级任务调度问题

思路：

- 检测环并去环
- 拓扑排序

算法：

- 定义任务和优先级
- 不断检测并去除环
- 对图进行拓扑排序

#### 强连通性

##### 寻找有向图的强连通分量：Kosaraju 算法

- 得定有向图 G，计算其反向图的逆后序排列
- 在 G 中按照上面给出的排列访问所有未标记的点

##### 顶点对的可达性

问题：是否存在一条给定顶点对间的有向路径？

- 传递闭包法
- DFS 法

### 加权图：最小生成树

问题：

- 在一幅加权（权值各不相同）的连通无向图
- 求该图的最小生成树 MST

基础理论：

- 树中加边：产生环
- 树中删边：得到两棵树

- 图的切分：将图的两个顶点分为两个非空且不重合的集合
- 图的横切边：连接两个集合顶点的边

切分定理：

- 对于图的任意切分，横切边中的最小边必然属于 MST

基本算法：贪心策略

- 从树中点和非树中点的集合中找到一条最小横切边加入 MST，更新两个集合
- 一共找 V - 1 条边

加权无向图的数据类型：

- 邻接矩阵：将布尔值换为权重
- 邻接表：在 node 中增加一个权重域
- 邻接表 + 边类型：由于 MST 主要关注edge，因此将邻接表中的点类型换为边类型更好实现算法

##### Prim 算法

- DSA
  - 顶点数组：保存点集关系（也是一个 uf 数组）
  - 边：使用队列保存 MST 的边，或者用 uf 数组来保存边
  - 横切边：minPQ
- 算法
  - 每次选择一条最小横切边加入 MST 中
  - 维护 minPQ 中的切边集合，需要清理失效的切边（两点都在 MST 中的边）
- 延时实现：
  - 将新节点的邻接边都加入 minPQ 中，需要时再清理失效边
  - 时间复杂度 E
  - 空间复杂度 ElogE
- 即时实现：
  - minPQ 中只保存最小权的边，动态清理失效的边
  - 时间复杂度 V
  - 空间复杂度 ElogV

##### Kruskal 算法

- DSA
  - 使用 minPQ 对边排序
  - 使用 uf 来识别环
  - 使用 queue 来保存 MST
- 算法
  - 按照所有边的边权顺序将边加入 MST 中，不加入将树引入环的边
  - 知道 V - 1 条边为止
- 实现
  - 时间复杂度 V
  - 空间复杂度 E + VlogV

### 加权有向图：最短路