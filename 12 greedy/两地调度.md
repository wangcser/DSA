# 两地调度
> Author ID.9276 

**问题关键词：**

- 贪心

## 01 题目

公司计划面试 `2N` 人。第 `i` 人飞往 `A` 市的费用为 `costs[i][0]`，飞往 `B` 市的费用为 `costs[i][1]`。

返回将每个人都飞到某座城市的最低费用，要求每个城市都有 `N` 人抵达**。**

**示例：**

```
输入：[[10,20],[30,200],[400,50],[30,20]]
输出：110
解释：
第一个人去 A 市，费用为 10。
第二个人去 A 市，费用为 30。
第三个人去 B 市，费用为 50。
第四个人去 B 市，费用为 20。

最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。
```

 

**提示：**

1. `1 <= costs.length <= 100`
2. `costs.length` 为偶数
3. `1 <= costs[i][0], costs[i][1] <= 1000`

## 02 输入分析



## 03 解题思路

### 3.1 基础思路

贪心策略：

- 求每个人去 A 的成本和去 B 的成本的差值
- 利用这个差值对序列排序
- 选择前 N 个人去 A，剩下的人去 B

不严谨的证明：

- 差值代表了从公司的角度出发这个人去两个城市面试的**机会成本**的差异：
  - 小于 0，这个人更适合去 A
  - 大于 0，更适合去 B
- 排序代表了公司优先选择**机会成本**最小的人

## 3.2 算法优化

本题思路简单，但是实现起来还是很考验技术的，这里借助 STL 的模板排序来简化状态的使用

在求和的时候利用了左闭右开的区间特性

## 04 核心代码

```c++
class Solution {
public:
    int twoCitySchedCost(vector<vector<int>>& costs) {
        
        int cost = 0;
        
        sort(costs.begin(), costs.end(), 
             [](vector<int> a, vector<int> b) {return a[0] - a[1] < b[0] - b[1];});
        
        for(int i = 0; i < costs.size() / 2; i++) cost += costs[i][0];
        
        for(int i = costs.size() / 2; i < costs.size(); i++) cost += costs[i][1];
        
        return cost;
        
    }
};
```



## 05 算法效率分析



## 06 问题总结

