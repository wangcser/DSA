# 盛水最多的容器
问题关键词：

- 对撞指针

## 01 题目

给定 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器，且 *n* 的值至少为 2。

![img](盛水最多的容器.assets/question_11.jpg)

图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 

**示例:**

```
输入: [1,8,6,2,5,4,8,3,7]
输出: 49
```

## 02 分析

盛水的容量取决于杯壁的最小高度和杯壁间的最大宽度

- 穷举法：找到所有容器的组合求最大容积

- 对撞指针，这里需要证明遍历过程包含最大值

## 03 题解

### 优化：对撞指针

- 对撞策略：哪边的高度最低就更新哪边的高度
- 证明：遍历过程中一定包含最优解
  - 假设上图中最优解来自于 nums[0] ~ nums[7]，而非 nums[1]~nums[8]
  - 由于二者宽度相同，因此必然有min(nums[0], nums[7]) > min(nums[1], nums[8])，也就是 nums[0] > nums[8]，也就是更新了右侧的边界，和已知矛盾

```c++
//version 1.0 0.0%

class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0;
        int r = height.size() - 1;
        int ans = 0;
        
        while(l < r) {
            
            ans = max(ans, min(height[l], height[r]) * (r - l));
            
            if(height[l] < height[r]) l++;
            else r--;
        }
        
        return ans;
    }
};
```

## 04 总结

