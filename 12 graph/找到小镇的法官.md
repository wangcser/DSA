# 找到小镇的法官
关键词:

- 有向图
- degree

## 01 题目

在一个小镇里，按从 `1` 到 `N` 标记了 `N` 个人。传言称，这些人中有一个是小镇上的秘密法官。

如果小镇的法官真的存在，那么：

1. 小镇的法官不相信任何人。
2. 每个人（除了小镇法官外）都信任小镇的法官。
3. 只有一个人同时满足属性 1 和属性 2 。

给定数组 `trust`，该数组由信任对 `trust[i] = [a, b]` 组成，表示标记为 `a` 的人信任标记为 `b` 的人。

如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 `-1`。

 

**示例 1：**

```
输入：N = 2, trust = [[1,2]]
输出：2
```

**示例 2：**

```
输入：N = 3, trust = [[1,3],[2,3]]
输出：3
```

**示例 3：**

```
输入：N = 3, trust = [[1,3],[2,3],[3,1]]
输出：-1
```

**示例 4：**

```
输入：N = 3, trust = [[1,2],[2,3]]
输出：-1
```

**示例 5：**

```
输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
输出：3
```

 

**提示：**

1. `1 <= N <= 1000`
2. `trust.length <= 10000`
3. `trust[i]` 是完全不同的
4. `trust[i][0] != trust[i][1]`
5. `1 <= trust[i][0], trust[i][1] <= N`

## 02 分析

- 法官是只有入度没有出度的人
- 法官的入度为人数 - 1
  - 问题转化为统计每个节点的度



- 本题也可以看做是一个并查集问题，法官是所有其他节点的 root
- 法官本身是自己的 root （法官没有出度）
- 因此检查所有节点，若只有一个 root，且每个人的 root 都相同，则该 root 是法官

## 03 题解

### 基础：统计每个节点的入度和出度

- 通过扫描有向边数组就能够完成

```c++
//version 1.0 0.0%
class Solution {
public:
    int findJudge(int N, vector<vector<int>>& trust) {
        
        // int degree[N + 1][2]; // this is hard to init
        vector<vector<int>> degree(N + 1, vector<int>(2, 0));
        
        for(int i = 0; i < trust.size(); i++) {
            degree[trust[i][0]][0]++; // out 
            degree[trust[i][1]][1]++; // in
        }
        
        for(int i = 1; i <= N; i++) {
            if(degree[i][0] == 0 && degree[i][1] == N - 1)
                return i;
        }
        
        return -1;
    }
};
```

## 04 总结

