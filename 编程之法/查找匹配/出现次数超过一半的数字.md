# 出现次数超过一半的数字
> Author ID.9276 

**问题关键词：**

- 

## 01 题目

数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。

## 02 输入分析

一个数组中有很多数，现在我们要找出其中那个出现次数超过总数一半的数字，怎么找呢？大凡当我们碰到某一个杂乱无序的东西时，我们人的内心本质期望是希望把它梳理成有序的。所以，我们得分两种情况来讨论，**无序和有序**。

## 03 解题思路

### 3.1 基础解法

#### 排序 + 遍历

- 如果**无序**，那么我们是不是可以先把数组中所有这些数字**先进行排序**（至于排序方法可选取最常用的快速排序）。排完序后
- 直接遍历，在遍历整个数组的同时统计每个数字的出现次数，然后把那个出现次数超过一半的数字直接输出，题目便解答完成了。
- 总的时间复杂度为O(nlogn + n)

#### 排序 + 直接输出中位数

- 但**如果是有序的数组呢**，或者经过排序把无序的数组变成有序后的数组呢？是否在排完序O(nlogn)后，还需要再遍历一次整个数组？
- 我们知道，既然是数组的话，那么我们可以根据数组索引支持直接定向到某一个数。我们发现，一个数字在数组中的出现次数超过了一半，那么在已排好序的数组索引的N/2处（从零开始编号），就一定是这个数字。自此，我们只需要对整个数组排完序之后，然后直接输出数组中的第N/2处的数字即可，这个数字即是整个数组中出现次数超过一半的数字
- 总的时间复杂度由于少了最后一次整个数组的遍历，缩小到O(n*logn)。

### 3.2 优化

#### 使用 hash 表进行统计

- 既要缩小总的时间复杂度，那么可以用查找时间复杂度为O(1)的**hash表**，即以空间换时间。
- 算法：
  - 哈希表的键值（Key）为数组中的数字，值（Value）为该数字对应的次数。
  - 直接遍历整个**hash表**，找出每一个数字在对应的位置处出现的次数，输出那个出现次数超过一半的数字即可
- 分析：
  - 时间上 O(n)
  - 空间上 O(n / 2)

#### 减治：删除法

- 分析
  - 每次删除两个不同的数，剩下的序列依然满足要求
  - 不断重复上面的过程，直到不可删除为止，此时序列中只剩一种元素，就是解
- 复杂度
  - 时间上 O(n)
  - 空间上 O(1)
- 难点
  - 需要不断地对序列执行动态操作

#### 计数法

更进一步，考虑到这个问题本身的特殊性，我们可以在遍历数组的时候保存两个值：一个candidate，用来保存数组中遍历到的某个数字；一个nTimes，表示当前数字的出现次数，其中，nTimes初始化为1。当我们遍历到数组中下一个数字的时候：

- 如果下一个数字与之前candidate保存的数字相同，则nTimes加1；
- 如果下一个数字与之前candidate保存的数字不同，则nTimes减1；
- 每当出现次数nTimes变为0后，用candidate保存下一个数字，并把nTimes重新设为1。 直到遍历完数组中的所有数字为止。

举个例子，假定数组为{0, 1, 2, 1, 1}，按照上述思路执行的步骤如下：

- 1.开始时，candidate保存数字0，nTimes初始化为1；
- 2.然后遍历到数字1，与数字0不同，则nTimes减1变为0；
- 3.因为nTimes变为了0，故candidate保存下一个遍历到的数字2，且nTimes被重新设为1；
- 4.继续遍历到第4个数字1，与之前candidate保存的数字2不同，故nTimes减1变为0；
- 5.因nTimes再次被变为了0，故我们让candidate保存下一个遍历到的数字1，且nTimes被重新设为1。最后返回的就是最后一次把nTimes设为1的数字1。

## 04 问题总结

加强版水王：找出出现次数刚好是一半的数字

分析：我们知道，水王问题：有N个数，其中有一个数出现超过一半，要求在线性时间求出这个数。那么，我的问题是，加强版水王：有N个数，其中有一个数刚好出现一半次数，要求在线性时间内求出这个数。

因为，很明显，如果是刚好出现一半的话，如此例： 0，1，2，1 ：

```
遍历到0时，candidate为0，times为1
遍历到1时，与candidate不同，times减为0
遍历到2时，times为0，则candidate更新为2，times加1
遍历到1时，与candidate不同，则times减为0；我们需要返回所保存candidate（数字2）的下一个数字，即数字1。
```