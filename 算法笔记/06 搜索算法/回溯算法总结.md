# 回溯算法总结

## 00 为什么要掌握回溯法
- 学会了回溯算法之后笔试里的很多题就算 AC 不了，起码成功运行 70% 到 90% 之间是没问题的
- 如果笔试题里有的数据集设计的不够好，那么回溯甚至可以比动态规划运行的还快
- 这对于获得面试机会已经足够了
- 并且回溯很优美，很容易理解，因为说到底它不过就是个填格子的游戏罢了

## 01 什么是回溯算法

**回溯算法可以看做是对蛮力穷举搜索的改进，但他本质上依然是穷举搜索**，下面我们来分析这一说法的理由。

### 穷举搜索，所有算法的起点

对于一个算法问题来说，我们总是可以**通过枚举问题的解来求解问题**，在枚举的过程中需要考虑下面的三个因素：

1. 如何保证**不重复**枚举
2. 如何保证**不遗漏**枚举
3. 如何从上一步的结果得到下一步的枚举（搜索）方向（**状态如何转移**）

解决了上面的三个问题，也就能解决一般的枚举（搜索）问题，但是**算法的复杂度等于解空间的大小**（一般为指数复杂度）。

对算法的优化，就是对解空间的优化，也就是对解空间树的优化。

基于上面的铺垫，我们开始讨论回溯算法。

### 回溯算法的定义

回溯算法（试探法），是一种系统地**搜索**问题的解的方法，**在搜索过程中逐步构建更多的候选解**，并通过问题的约束条件确定某一部分候选解不能够成正确解的时候，放弃这一部分的搜索，转而测试其他部分的候选解（高效地搜索）。

### 回溯算法的算法思想

- 在搜索过程中从一条路往前走，能进则进，不能进就换一条路试试
- 直到找到问题的所有解或者证明解不存在

### 回溯算法的设计步骤

1. 定义一个解空间，它包含了问题的解
2. 利用利于进行搜索的方法组织解空间，并**在搜索过程中动态生成新的子解空间**
3. **使用 DFS（或 BFS）方法搜索解空间**
4. **利用限界函数避免搜索到不可能产生解的子空间**

### 回溯算法的典型应用

1. 八皇后问题
2. 图的着色问题
3. 装载问题
4. 批处理作业调度问题
5. 背包问题
6. 最大团问题
7. 圆排列问题
8. 连续邮资问题
9. 符号三角形问题
10. 集合划分问题
11. …

## 02 回溯算法的特点

### 算法可以解决的问题

拿到一个问题，你感觉如果不穷举一下就没法知道答案，那就可以开始回溯了，一般回溯可以解决的问题为：

1. Find a path to success 有没有解
2. Find all paths to success 求所有解
   - 求所有解的个数
   - 求所有解的具体信息
3. Find the best path to success 求最优解

关于回溯的三种问题，模板设计略有不同：

1. 回溯返回值是 true/false
2. 求个数，设全局 counter，返回值是 void
3. 求所有解信息，设 result，返回值 void
4. 设个全局变量 best，返回值是 void

### 解空间树

从解空间的角度可以更加方便且清晰地理解回溯算法，先看什么是解空间。

直观地说，**解空间就是输入的序列：形如数组的一个向量 [a1,a2,....,an]**。

- 这个向量的每个元素都是问题的部分解，
- 只有当这个数组的每一个元素都**填满**(得到全部解)的时候，才表明这个问题得到了解答。

对解空间的搜索，就是循环遍历，最简单的就是 for 循环，上面的**向量有 n 个维度，因此就是 n 个 for 循环**，表现为下面的形式。

```
for(求a1位置上的解)
   for(求a2位置上的解)
      for(求a3位置上的解)
       ......
       ......
       for(求an位置上的解)
```

回溯中用于搜索的解空间可以抽象为一棵树，我们将其称之为解空间树。我们的目标可以是找这个树有没有 good leaf，也可以是问有多少个 good leaf，也可以是找这些 good leaf 都在哪，也可以问哪个 good leaf 最好，分别对应上面所说回溯的问题分类。

解空间树：又称状态空间树，指将问题的解空间以树的方式进行组织

- **可行解：**解空间中满足约束条件的解空间；
- **最优解**：解空间中使目标函数取最大或者最小值的可行解
- **根节点位于第一层，代表搜索的初始状态**
- 下方的节点在搜索过程中动态展开

解空间树的动态搜索：

- 搜索到树中任一节点时，**先判断该节点对应的部分是否包含问题的最优解**（满足约束条件或超出目标函数的界）
  - 不包含，跳过多该节点为 root 的子树的搜索（剪枝）
  - 包含，进入该子树继续 DFS 搜索

回溯算法常用的典型解空间树：

1. **子集树**，问题是从n个元素的集合中找出满足某种性质的子集
2. **排列树**，问题是确定n个元素满足某种性质的排列

### 回溯算法的特点

1. 通常使用递归算法来实现
2. 使用解空间树来进行动态搜索
3. 使用减枝函数来优化解空间树
4. 最坏情况下会导致指数时间复杂度（搜索整个解空间树）
5. 优点：结构明确，可读性强，易于理解

## 03 如何设计回溯算法

回溯算法设计的关键在于以下三点：

1. 节点如何扩展
2. 解空间树如何搜索，DFS —— 回溯法，BFS —— 分支限界法
3. 如何高效地找到问题的解

### 设计思路

1. 按照DFS算法的策略，从根结点出发搜索解空间树。首先根结点成为活结点（指自身已生成但其孩子结点没有全部生成的结点），同时也成为当前的扩展结点（指正在产生孩子结点的结点，也称为E结点）

2. 在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为新的活结点，并成为当前扩展结点。如果在当前的扩展结点处不能再向纵深方向移动，则当前扩展结点就成了死结点（指其所有子结点均已产生的结点）。此时应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。

3. 回溯法以这种方式递归地在解空间中搜索，直到找到所要求的解或解空间中已无活结点为止。

这里注意：

1. 由于采用回溯法求解时存在退回到祖先结点的过程，所以需要保存搜索过的结点。通常有两种：
   1. 用子定义栈来保存；
   2. 采用递归方法。
2. 用回溯法通常采用两种策略避免无效搜索。
   1. 用约束函数在扩展结点处剪除不满足约束条件的路径；
   2. 用限界函数剪去得不到问题的解或最优解的路径（这两类函数统称为剪枝函数）

### 用回溯法求解的一般步骤

1. 针对给定的问题确定问题的解空间树
2. 确定结点的扩展搜索规则
3. 以深度优先方式搜索解空间树，并在搜索过程中可以采用剪枝函数来避免无效搜索。其中，深度优先方式可以采用递归回溯或者非递归（迭代）回溯

## 04 如何优化回溯算法 —— 减枝

减枝的本质在于从题目的条件中提取可用于优化搜索路径的信息作为搜索的约束条件。因此，具体的方法要结合题目具体分析。

## 05 算法模板

### 问题抽象

给定一些元素，求满足特定条件的所有组合，表现为下面三种形式：

1. 排列 Permutation
2. 组合 Combaination，取子集 SubSet
3. 分割 Palindrome Partitioning

我们在模板中可以按照下面的方式进行处理：

1. 按照输入序列的顺序，或者对输入序列排序（用于解决有重复元素的情况，使用下标遍历）
2. **每一次调用递归地处理一个元素**
3. **处理到最后一层时，将结果加入解集**

需要注意的是，**每次递归到下一层时，应该按照下面的逻辑进行处理**：

1. 标记要处理元素
2. 将元素加入路径
3. 处理
4. 将元素取出路径
5. 取消该元素的标记

### 关键实现 —— 由迭代改为递归

回顾解空间树中我们对解的搜索的分析，当序列大小 n 是 100、100000 时，基于迭代的回溯算法设计变得很困难（当然也可以写n个for循环，但是这样的程序会惨不忍睹）。因此我们需要一种全新的书写回溯的方法。形如：

```
void backtrack(int i,int n,other parameters)
{
  if( i == n)
{
 //get one answer
record answer;
return;
}
//下面的意思是求解空间第i个位置上的下一个解
for(next ans in position i of solution space)
{
  backtrack(i+1,n,other parameters);
}
}
```

上面的 i 代表解空间的第i个位置，往往从 0 开始，而 n 则代表解空间的大小。每一次的 backtrack(i,n,other) 调用,代表求**解空间**第i个位置上的解。而当i=n时，代表解空间上的所有位置的解都已经求出。
有了上述**模板**，我们就解决了**搜索**的问题。因此**几乎**所有回溯的问题的难度都在于如何定义**解空间**。

> 因此我们看到，回溯本身是很简单的，单纯的模板套用，难的在于需要根据回溯条件来定义各种别的变量，以及最后结果的记录。

### 模板——排列问题

```c++
// template for backtracking algo.
class Solution {
public:
    vector<vector<int>> ans; // 使用全局变量，标记数组也可以这么设计

    void solve() {
        vector<vector<int>> permuteUnique(vector<int> &s) {
            vector<int> cur;
            vector<bool> visited(s.size(), false);
            
            sort(s.begin(), s.end());

            // 搜索的起点
            backtrack(s, cur, visited);

            return ans;
        }
    }
	
    // s 为搜索的空间， cur 为当前的搜索路径， visited 为路径标记
    void backtrack(vector<int>& s, vector<int>& cur, vector<bool>& visited) {
        // 1. 结束条件，该分支搜索完毕
        // 对于排列问题，只有当搜索到叶子节点时才加入解集
        if(cur.size() == s.size()) {
            ans.push_back(cur);
            return;
        }
        // 2. 加入一些减枝策略

        // 3. DFS 深入搜索
        for(int i = 0; i < s.size(); i++) {
            // 搜索路径去重
            if（visited[i]) continue;
            
            visited[i] = true;
            cur.push_back(s[i]);
            backtrack(s, cur.push_back(s[i]), visited);
            cur.pop_back(s[i]); // 关键
            visited[i] = false; // 关键
        }
    }
}
```

### 模板——组合问题（子集）

```c++
class Solution {
public:
    vector<vector<int>> ans; // 使用全局变量，标记数组也可以这么设计

    void solve() {
        vector<vector<int>> permuteUnique(vector<int> &s) {
            vector<int> cur;
            vector<bool> visited(s.size(), false);
            
            sort(s.begin(), s.end());

            // 搜索的起点
            backtrack(s, cur, visited);

            return ans;
        }
    }
	
    // s 为搜索的空间， cur 为当前的搜索路径， visited 为路径标记
    void backtrack(vector<int>& s, vector<int>& cur, vector<bool>& visited) {
        // 对于组合问题，路径上所有结果都加入解集
        ans.push_back(cur);
        
        // 1. 结束条件，该分支搜索完毕
        if(cur.size() == s.size()) return；

        // 2. 加入一些减枝策略

        // 3. DFS 深入搜索
        for(int i = 0; i < s.size(); i++) {
            // 搜索路径去重
            if（visited[i]) continue;
            
            visited[i] = true;
            cur.push_back(s[i]);
            backtrack(s, cur.push_back(s[i]), visited);
            cur.pop_back(s[i]); // 关键
            visited[i] = false; // 关键
        }

    }
}
```

## 06 总结：回溯与 DFS 的区别

两者的不同点如下：

1. 访问的次序不同：
   1. DFS 的目的是遍历，**本质是无序的**，重要的是节点是否被访问过，因此在实现上只需要对于每个位置是否被访问过进行记录就足够了
   2. 回溯法的目的是求解过程，**本质是有序的**，也就是说必须每一步都是要求的次序

2. 访问次数不同：
   1. 深度优先遍历对已经访问过的顶点不再访问
   2. **回溯法中已经访问过的顶点可能再次访问**

3. 剪枝不同：深度优先遍历不含剪枝

>  实际上，除了剪枝是回溯法的一个明显特征外（并非任何回溯法都包含剪枝部分），很难严格区分回溯法与深度优先遍历。因为这些算法很多是递归算法，**在递归调用中隐含着状态的自动回退和恢复**。

## Reference

- 定义：[https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95](https://zh.wikipedia.org/wiki/回溯法)
- 经典问题：<https://blog.csdn.net/qq_32400847/article/details/51474105>
- 解空间树：<https://blog.csdn.net/qq_37763204/article/details/79519671>
- Leetcode 回溯实战：<https://segmentfault.com/a/1190000006121957>
- 回溯的设计：<https://segmentfault.com/a/1190000018319044>
- 模板的设计：<https://zhuanlan.zhihu.com/p/28340833>