# 买卖股票问题总结

买卖股票系列问题总结了经典 DP 设计的思路和讨论。

## 问题的基本面

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格，你可以进行的操作如下（对于第 i 天）：

- 之前未持有股票，则可以在某一天买入该股票
- 之前已经持有股票，则可以在某一天卖出该股票
- 这一天不执行任何操作，观望
  - 不能在买入股票前卖出股票
- 每一天只能执行上面三种操作中的一种

求在考虑下面约束的前提下，你能获得的最大收入

## 问题分析

该系列的问题是个序列优化问题，每一步的操作都取决于之前的操作，因此我们考虑将问题建模为动态规划问题。

首先定义问题的状态：该交易日能获得的最大收益为 opt(i, j, k) 

- 第一个维度 i 代表交易的日期
- 第二个维度 j 代表交易的次数
- 第三个维度 k 代表当前是否持有股票，以及是否能够交易
  - 我们可以根据这个维度的值选择我们可以进行的状态

然后分析问题的状态转移方程：



最后分析问题的初始情况和边界情况：



实现上的细节：

- 我们将买入股票相当于成本的增加，我们将其定义为负收益的增加

## 00 尽可能交易

<<https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/comments/>>

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 
```

#### 二维 DP

定义状态：这里我们将二维状态拆分为以下两个状态，便于问题的描述和算法的实现：

- buy(i) 代表在 i 个交易日进行了买入或者在之前买入，目前观望等待买入的最大的收益
  - 历史最后操作是买入的最大收益
  - 当天持有股票的收益
- sell(i) 代表在 i 个交易日进行了卖出或者在之前持有，目前观望等待卖出的最大的收益
  - 历史最后操作是卖出的最大收益
  - 当天没有持有股票的收益

定义状态转移：

- 对于第 i 天，我们可以 [观望 | 未持有的情况下买入 | 持有的情况下卖出 ]
- buy[i] 代表我们在 i 交易日进行了买入操作或者观望，这时的收益取决于：
  - 买入：之前卖出的收益 + 今天买入的负收益
  - 买入观望：之前买入观望的收益
- 由于我们的目标是最大收益，因此对于两种转入的状态我们取其最大值

> 需要注意的是，这里我对观望也做了区分，否则我们考虑观望操作时会产生如下的疑惑：
>
>             sell[i] = max(max(sell[i - 1], buy[i - 1]), buy[i - 1] + prices[i]);
>             buy[i] = max(max(buy[i - 1], sell[i - 1]), sell[i - 1] - prices[i]);
> 这样的处理是不对的，因为两种“观望”是不同的，根本在于是否持有股票。

定义初始状态：我们使用表格法求解，存储所有的中间状态

- 由于我们求每一阶段的 max，因此每个状态初始化为 INT_MIN
- 对于第 1 天
  - 我们买入的收益为当天股票价格的成本
    - 回顾我们对 buy(i) 的定义，对于第一天我们必须要进行买入
  - 我们卖出的收益为 0，因为没有股票可卖
- 状态转移应该从第二天开始

问题最终返回最后一天的卖出收益即可，因为卖出收益不小于买入收益

对于 DP 策略实现如下：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        
        if(prices.size() < 1) return 0;
        
        int n = prices.size();
        vector<int> buy(n, INT_MIN);
        vector<int> sell(n, INT_MIN);
        
        buy[0] = -prices[0];
        sell[0] = 0;
        
        for(int i = 1; i < n; i++) {
            sell[i] = max(sell[i - 1], buy[i - 1] + prices[i]);
            buy[i] = max(buy[i - 1], sell[i - 1] - prices[i]);
        }
        
        return sell[n - 1];
    }
};
```

## 贪心策略

当然在这个约束下问题还有比较简单的思路——贪心策略

贪心策略：只要相邻两天收益为正就进行一次买卖操作

- 首先遍历序列，计算相邻元素的差值，对于单个差值，分析如下：
  - 若差值为正，说明在这两天买入和卖出获得了利润
  - 若差值为负，说明在这两天买入和卖出增加了成本，也就是增加了负利润
- 再分析不相邻元素之间的连续差值
  - 若存在连续的正差值，说明我们在区间的起始位置买入，在区间的结束位置卖出获得的利润和正差值的和相等，这样就解决了同一天买卖的问题
  - 对于负差值同理
- 最后来分析正负差值交错的情况
  - 此时我们总是选择正差值进行买卖即可，不会出现同一天买卖的问题

上面分析了基于差值序列进行操作的方法，那么我们应该如何计算最大收益呢？很简单，上面操作所能获得的最大利润就是所有正差值的和：

- 对于交叉差值，显然可得
- 对于连续正差值，上述操作的结果就是求和

下面对这个贪心策略进行实现：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        
        if(prices.size() < 1) return 0;
        
        int n = prices.size();
        vector<int> profit(n, INT_MIN);
        int ans = 0;
        
        // init the first profit is 0
        profit[0] = 0;
        
        // cal the diff
        for(int i = 1; i < n; i++)
            profit[i] = prices[i] - prices[i - 1];
        
        // add the positive profit
        for(auto p : profit)
            if(p > 0) ans += p;
        
        return ans;
    }  
};
```

## 01 最多交易 1 次

<https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/comments/>



## 02 最多交易  2 次

<https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/comments/>

## 03 最多交易 k 次

<https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/comments/>

## 04 每次交易含有手续费

## 05 每次交易含有冷冻期



## Reference

待定吧，目前已经优点思路了，一方面要考虑使用统一的解法来求解，另一方面又要考虑问题的个性，设计更高偶的简单的方法