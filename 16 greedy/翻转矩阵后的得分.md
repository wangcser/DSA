# 翻转矩阵后的得分
**问题关键词：**

- 贪心

## 01 题目

一个二维矩阵 A 其中每个元素的值为 0 或 1 。

移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。

在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

返回尽可能高的分数。

 

示例：

输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
输出：39
解释：
转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39


提示：

1 <= A.length <= 20
1 <= A[0].length <= 20
A[i][j] 是 0 或 1

## 02 分析

思路：
可以这样看，n*m的每个格子都具有一个权重，其中每一行权重都自左向右递减，
为使总和最大则尽可能使权重大的格子填“1”。最左边一列权重最大，所以总可以通过
行翻转使左边第一列全都置“1”，后面就不能再使用行翻转了，以免破环当前的结构，
所以考虑列翻转。对于除最左边第一列外的每一列，总可以通过列翻转使得该列“1”
的个数不小于“0”的个数。最后所有填“1”的格子的权重和即为答案。

## 03 题解

### 基础

贪心策略：

- 如果某一行以 0 开头，则翻转该行，翻转过后值会增加
  - 这样所有的行都以 1 开头
- 然后从第二列开始，如果该列 0 更多，则翻转该列
  - 这样每列的权重都一样，1 的数量会多于 0 的数量

```c++
class Solution {
public:
    int matrixScore(vector<vector<int>>& A) {
        
        if(A.size() == 0) return 0;
        
        int m = A.size();
        int n = A[0].size();
        int ans = 0;
        
        for(int i = 0; i < m; i++) {
            if(A[i][0] == 0)
                flipRow(A, i);
        }
        
        for(int j = 1; j < n; j++) {
            int one = 0;
            int zero = 0;
            for(int i = 0; i < m; i++) {
                if(A[i][j] == 1)
                    one++;
                else
                    zero++;
            }
            if(zero > one)
                flipCol(A, j);
        }
        
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(A[i][j] == 1)
                    ans += 1 << (n - 1 - j); 
            }
        }
        
        return ans;
    }
    
    void flipRow(vector<vector<int>>& A, int i) {
        
        for(int j = 0; j < A[0].size(); j++) {
            A[i][j] = 1 - A[i][j];
        }
    }
    
    void flipCol(vector<vector<int>>& A, int j) {
        
        for(int i = 0; i < A.size(); i++) {
            A[i][j] = 1 - A[i][j];
        }
    }
};
```

## 04 总结

- 注意，这里使用了移位运算来计算幂，底数为 1 不是 2